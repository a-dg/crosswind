@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// /**
//  * Define column counts
//  * @param {map} $set
//  */
@mixin grid_setup($set) {
	@each $breakpoint, $column_count in $set {
		@include b($breakpoint) {
			grid-template-columns: repeat($column_count, 1fr);
		}
	}
}


// /**
//  * Define responsive layout
//  * 
//  * For any one item, the parameters can be any combination of:
//  * 6,     // 6 columns wide
//  * 8 3,   // 8 columns wide, starting on column 3
//  * -1,    // Full-width (same as -1 1)
//  * -2 3,  // Start on column 3, end on the second column from the end
//  * r 2,   // 2 rows tall
//  * r 1 4, // 1 row tall, starting on row 4
//  * o -2,  // order -2
//  * 
//  * Parameters must be specified in this order:
//  * - column span [column start]
//  * - row span [row start]
//  * - order
//  * 
//  * Specify parameters for one item using space-delimited lists:
//  * @include layout((
//  *   sm: 6,
//  *   md: 10 1 r 2,
//  *   lg: 8 3,
//  * ));
//  * 
//  * Specify parameters for multiple items, separated by commas:
//  * @include layout((
//  *   sm: (6, 6, 6),
//  *   md: (7 2, 5 r 2, 6 o -2),
//  *   lg: (8, 4),
//  * ));
//  * 
//  * Enabling repeat causes parameters to affect all items, using
//  * multipliers for CSS selectors:
//  * - Repeat off: :nth-child(2)
//  * - Repeat on:  :nth-child(2n)
//  * 
//  * Repeat enabled: odd-numbered items will be 8 columns wide, and
//  * even-numbered items will be 4 columns wide:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: true);
//  * 
//  * Repeat disabled: any items past the second one will not inherit their
//  * settings from smaller breakpoints, or not have any settings:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: false);
//  * 
//  * @param {map} $set
//  * @param {boolean} $repeat
//  * @param {boolean} $self
//  */
@mixin layout($set, $repeat: true, $self: false) {
	$delimiter_row: r;
	$delimiter_order: o;
	
	@each $breakpoint, $elements in $set {
		@if
			meta.type_of($elements) != list
			or list.separator($elements) != comma
		{
			$elements: ($elements,);
		}
		
		// Use next-smallest breakpoint to avoid creating over-zealous item styles
		// that are difficult to override at larger breakpoints
		// TODO: this may be unnecessary for many grid styles, it may be most
		// useful when the number of items in a row is changing and the items on
		// ends of each row have specific styles, such as the wire grid
		$next_smallest_breakpoint: find_next_smallest_breakpoint(
			map.keys($set), $breakpoint
		);
		
		@include b($breakpoint) {
		// @include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
			@for $index from 1 through list.length($elements) {
				$list: list.nth($elements, $index);
				
				// Split params to separate order from column and row
				$split_column_row_order: split_list($list, $delimiter_order);
				$column_row: map.get($split_column_row_order, a);
				$order: map.get($split_column_row_order, b);
				
				// Split params to separate row from column
				$split_column_row: split_list($column_row, $delimiter_row);
				$column: map.get($split_column_row, a);
				$row: map.get($split_column_row, b);
				
				// TODO: if repeat and all elements have the same config, only spit out
				// the rules once
				// Example: sm: (6, 6, 6) => sm: (6)
				
				// TODO: keep track of settings from breakpoint to breakpoint, and if
				// an element uses the same settings as the previous breakpoint, don't
				// repeat those rules
				// Example: (
				//   sm: (6, 4),
				//   md: (6, 3), => Don't repeat rules for first element
				//   lg: (6, 3), => Don't repeat rules for first or second element
				//   xl: (8, 2),
				// )
				
				@if $self {
					// TODO: is there a better way to do this?
					@include grid_plot($column, $row, $order);
				} @else {
					@if $index == 1 and $repeat {
						// TODO: could possibly see how many items there are in the
						// definition and use that to create a selector for the first item
						// that's more like :nth-child(2n+1), so that it doesn't apply to
						// all items in the grid, most of which are then overridden
						> .i {
							@include grid_plot($column, $row, $order);
						}
					} @else {
						> .i:nth-child(#{$index}#{if($repeat, n, '')}) {
							@include grid_plot($column, $row, $order);
						}
					}
				}
			}
		}
	}
}


// /**
//  * Grid plot
//  * @param {int/list} $column
//  * @param {int/list} $row
//  * @param {int} $order
//  */
@mixin grid_plot($column, $row, $order) {
	@if $column {
		@include grid_plot_axis(column, $column);
	}
	@if $row {
		@include grid_plot_axis(row, $row);
	}
	@if $order {
		order: $order;
	}
}


// /**
//  * Grid plot axis
//  * @param {string} $type (row or column)
//  * @param {int/list} $params
//  */
@mixin grid_plot_axis($type, $params) {
	@if 
		meta.type_of($params) == list
		and list.length($params) == 1
	{
		$params: list.nth($params, 1);
	}
	
	$has_start: meta.type_of($params) == list;
	@if $has_start {
		$span: if(list.nth($params, 1) > 0, span, unquote(''));
		grid-#{$type}: list.nth($params, 2) / $span list.nth($params, 1);
		@if $type == column {
			--content-width: #{list.nth($params, 1)};
		}
	} @else {
		$start: if($params > 0, auto, 1);
		$span: if($params > 0, span, unquote(''));
		grid-#{$type}: $start / $span $params;
		@if $type == column {
			--content-width: #{$params};
		}
	}
}


@mixin warning($message) {
	position: relative;
	overflow: auto;
	&::before {
		content: $message;
		position: absolute;
		z-index: 9999;
		left: 12px;
		top: 12px;
		padding: 24px 28px;
		width: 300px;
		// border: 8px solid #f09;
		border-radius: 24px;
		background: $color_warning;
		font-size: 24px;
		color: #fff;
		box-shadow: 8px 0 24px rgb(0 0 0 / 0.5);
	}
}


// /**
//  * Float element within grid
//  * - Explicit container width
//  * - Optionally implicit float offset
//  * 
//  * @param {string} $direction
//  * @param {int} $in ($container_column_count): Number of columns occupied
//  *   by containing element
//  * @param {int} $width ($float_column_count): Width of floated element
//  * @param {int} $offset ($float_offset_columns): Positive integer, -1 = auto
//  */
@mixin grid_float($direction, $in, $width, $offset: -1) {
	$opposite_direction: if($direction == right, left, right);
	$container_column_count: $in;
	$float_column_count: $width;
	$float_offset_columns: $offset;
	
	// TODO: add support for responsive params
	// $container_column_count: (
	// 	md: 8,
	// 	lg: 6,
	// ),
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	// TODO: $float_offset_columns doesn't really make sense, looks like it might have an off by one error
	
	// Calculate width of floated element
	$float_width: truncate(
		calc(($float_column_count / $container_column_count) * 100%)
	);
	$float_width_factor: truncate(
		calc(($container_column_count - $float_column_count) / $container_column_count)
	);
	
	// TODO: consider removing this auto calculation and making it a required parameter
	// TODO: $grid_columns will need to be responsive
	// Set float offset automatically when not specified, assuming the content
	// area is centered, and we want to send the floated element all the way to
	// the edge of the grid
	@if $float_offset_columns == -1 {
		$float_offset_columns: math.floor(
			calc(($grid_columns - $container_column_count) / 2)
		);
	}
	
	// What percentage of the content area width is the float offset?
	$float_offset_factor: calc($float_offset_columns / $container_column_count);
	$float_offset_percentage: truncate($float_offset_factor * -100%);
	
	$gutter_float: gutter(x, $as_list: true);
	$gutter_float_width: list_to_clamp(operate_list($gutter_float, $multiply: $float_width_factor));
	$gutter_float_offset: list_to_clamp(operate_list($gutter_float, $multiply: $float_offset_factor));
	
	float: $direction;
	width: calc($float_width - $gutter_float_width);
	margin-#{$opposite_direction}: gutter(x);
	
	// TODO: margin-#{direction} is unneccessary for 12-column container
	margin-#{$direction}: calc($float_offset_percentage - $gutter_float_offset);
}


// /**
//  * Float element within grid
//  * - Implicit container width
//  * - Explicit float offset
//  * 
//  * Advantages over grid_float():
//  * - Don't need to know the width of the floated element's container
//  * - Possibly less generated CSS?
//  * 
//  * Disdvantages:
//  * - Must specify the float offset explicitly
//  * - No automatically extending floated element to edge of grid
//  * 
//  * @param {string} $direction
//  * @param {int} $width ($float_column_count): Width of floated element
//  * @param {int} $offset ($float_offset_columns): Positive integer
//  */
@mixin grid_float_auto_container($direction, $width, $offset) {
	$opposite_direction: if($direction == right, left, right);
	$float_column_count: $width;
	$float_offset_columns: $offset;
	
	// TODO: add support for responsive params
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	// Calculate width of floated element
	$float_width: calc(($float_column_count * 100%) / var(--content-width));
	$float_width_factor: calc(1 - ($float_column_count / var(--content-width)));
	
	// What percentage of the content area width is the float offset?
	$float_offset_factor: calc($float_offset_columns / var(--content-width));
	$float_offset_percentage: calc(($float_offset_columns * -100%) / var(--content-width));
	
	float: $direction;
	width: calc($float_width - (gutter(x) * $float_width_factor));
	margin-#{$opposite_direction}: gutter(x);
	
	// TODO: margin-#{direction} is unneccessary for 12-column container
	margin-#{$direction}: calc($float_offset_percentage - (gutter(x) * truncate($float_offset_factor)));
}
