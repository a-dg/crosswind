@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// /**
//  * Define column counts
//  * @param {map} $set
//  */
@mixin grid_setup($set) {
	@each $breakpoint in map.keys($set) {
		$column_count: map.get($set, $breakpoint);
		@include b($breakpoint) {
			grid-template-columns: repeat($column_count, 1fr);
		}
	}
}


// /**
//  * Define responsive layout
//  * 
//  * For any one item, the parameters can be any combination of:
//  * 6,     // 6 columns wide
//  * 8 3,   // 8 columns wide, starting on column 3
//  * r 2,   // 2 rows tall
//  * r 1 4, // 1 row tall, starting on row 4
//  * o -2,  // order -2
//  * 
//  * Parameters must be specified in this order:
//  * - column span [column start]
//  * - row span [row start]
//  * - order
//  * 
//  * Specify parameters for one item using space-delimited lists:
//  * @include layout((
//  *   sm: 6,
//  *   md: 10 1 r 2,
//  *   lg: 8 3,
//  * ));
//  * 
//  * Specify parameters for multiple items, separated by commas:
//  * @include layout((
//  *   sm: (6, 6, 6),
//  *   md: (7 2, 5 r 2, 6 o -2),
//  *   lg: (8, 4),
//  * ));
//  * 
//  * Enabling repeat causes parameters to affect all items, using
//  * multipliers for CSS selectors:
//  * - Repeat off: :nth-child(2)
//  * - Repeat on:  :nth-child(2n)
//  * 
//  * Repeat enabled: odd-numbered items will be 8 columns wide, and
//  * even-numbered items will be 4 columns wide:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: true);
//  * 
//  * Repeat disabled: any items past the second one will not inherit their
//  * settings from smaller breakpoints, or not have any settings:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: false);
//  * 
//  * @param {map} $set
//  * @param {boolean} $repeat
//  */
@mixin layout($set, $repeat: true) {
	@each $breakpoint in map.keys($set) {
		$elements: map.get($set, $breakpoint);
		@if
			meta.type_of($elements) != list
			or list.separator($elements) != comma
		{
			$elements: ($elements,);
		}
		
		@for $index from 1 through list.length($elements) {
			$list: list.nth($elements, $index);
			
			// Split params to separate order from column and row
			$split_column_row_order: split_list($list, o);
			$column_row: map.get($split_column_row_order, a);
			$order: map.get($split_column_row_order, b);
			
			// Split params to separate row from column
			$split_column_row: split_list($column_row, r);
			$column: map.get($split_column_row, a);
			$row: map.get($split_column_row, b);
			
			@if $column {
				@include grid_plot(column, $breakpoint, $index, $column, $repeat);
			}
			@if $row {
				@include grid_plot(row, $breakpoint, $index, $row, $repeat);
			}
			@if $order {
				@include grid_plot_order($breakpoint, $index, $order, $repeat);
			}
		}
	}
}


// /**
//  * Grid plot
//  * @param {string} $type (row or column)
//  * @param {string} $breakpoint
//  * @param {int} $index
//  * @param {int / list} $params
//  * @param {boolean} $repeat
//  */
@mixin grid_plot($type, $breakpoint, $index, $params, $repeat: true) {
	@include b($breakpoint) {
		// TODO: see if you can group all of the rules for a single breakpoint
		// together, to minimize the number of media queries
		
		$has_start: (
			meta.type_of($params) == list
			and list.length($params) > 1
		);
		
		// TODO: if $index == 1, don't do :nth-child
		> :nth-child(#{$index}#{if($repeat, n, '')}) {
			@if $has_start {
				grid-#{$type}: list.nth($params, 2) / span list.nth($params, 1);
			} @else {
				grid-#{$type}: auto / span $params;
			}
		}
	}
}


// /**
//  * Grid plot order
//  * @param {string} $breakpoint
//  * @param {int} $index
//  * @param {int} $order
//  * @param {boolean} $repeat
//  */
@mixin grid_plot_order($breakpoint, $index, $order, $repeat: true) {
	@include b($breakpoint) {
		> :nth-child(#{$index}#{if($repeat, n, '')}) {
			order: $order;
		}
	}
}


@mixin warning($message) {
	position: relative;
	overflow: auto;
	&::before {
		content: $message;
		position: absolute;
		z-index: 9999;
		left: 12px;
		top: 12px;
		padding: 24px 28px;
		width: 300px;
		// border: 8px solid #f09;
		border-radius: 24px;
		background: $color_warning;
		font-size: 24px;
		color: #fff;
		box-shadow: 8px 0 24px rgb(0 0 0 / 0.5);
	}
}


// /**
//  * Float element within grid
//  * @param {string} $direction
//  * @param {int} $content_column_count
//  * @param {int} $float_column_count
//  * @param {int} $float_offset_columns
//  */
@mixin grid_float(
	$direction,
	$content_column_count,
	$float_column_count,
	$float_offset_columns: -1
) {
	// TODO: add support for responsive params
	// $content_column_count: (
	// 	md: 8,
	// 	lg: 6,
	// ),
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	$opposite_direction: if($direction == right, left, right);
	
	// Calculate width of floated element
	$float_width: truncate(
		calc(($float_column_count / $content_column_count) * 100%)
	);
	$float_width_factor: truncate(
		calc(($content_column_count - $float_column_count) / $content_column_count)
	);
	
	// TODO: consider removing this auto calculation and making it a required parameter
	// Set float offset automatically when not specified, assuming the content
	// area is centered, and we want to send the floated element all the way to
	// the edge of the grid
	@if $float_offset_columns == -1 {
		$float_offset_columns: math.floor(
			calc(($grid_columns - $content_column_count) / 2)
		);
	}
	
	// What percentage of the content area width is the float offset?
	$float_offset_factor: calc($float_offset_columns / $content_column_count);
	$float_offset_percentage: truncate($float_offset_factor * -100%);
	
	display: block;
	float: $direction;
	width: calc($float_width - (gutter(x) * $float_width_factor));
	margin-#{$opposite_direction}: gutter(x);
	
	// TODO: margin-#{direction} is unneccessary for 12-column container
	margin-#{$direction}: calc($float_offset_percentage - (gutter(x) * truncate($float_offset_factor)));
}
