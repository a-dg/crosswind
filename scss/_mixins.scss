@use 'sass:math';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// /**
//  * Define column counts
//  * @param {map} $set
//  */
@mixin grid_setup($set) {
	@each $breakpoint in map.keys($set) {
		$column_count: map.get($set, $breakpoint);
		@include b($breakpoint) {
			grid-template-columns: repeat($column_count, 1fr);
		}
	}
}


// /**
//  * Define responsive layout
//  * 
//  * Specify column span and offset for one item:
//  * @include layout((
//  *   sm: 6,   // 6 columns wide
//  *   lg: 8 3, // 8 columns wide, starting on column 3
//  * ));
//  * 
//  * Specify column span and offset for multiple items, separated by commas:
//  * @include layout((
//  *   sm: (6, 6),
//  *   md: (7 2, 5),
//  *   lg: (8, 4),
//  * ));
//  * 
//  * @param {map} $set
//  */
@mixin layout($set) {
	@each $breakpoint in map.keys($set) {
		$elements: map.get($set, $breakpoint);
		@if
			meta.type_of($elements) != list
			or list.separator($elements) != comma
		{
			$elements: ($elements,);
		}
		
		@for $i from 1 through list.length($elements) {
			$column_span: list.nth($elements, $i);
			@if
				meta.type_of($column_span) == list
				and list.separator($column_span) == space
			{
				@include b($breakpoint) {
					> :nth-child(#{$i}n) {
						grid-column: list.nth($column_span, 2) / span list.nth($column_span, 1);
			}
			}
			} @else {
	@include b($breakpoint) {
					> :nth-child(#{$i}n) {
						grid-column: auto / span $column_span;
			}
		}
	}
}
	}
}


@mixin warning($message) {
	position: relative;
	overflow: auto;
	&::before {
		content: $message;
		position: absolute;
		z-index: 9999;
		left: 12px;
		top: 12px;
		padding: 24px 28px;
		width: 300px;
		// border: 8px solid #f09;
		border-radius: 24px;
		background: $color_warning;
		font-size: 24px;
		color: #fff;
		box-shadow: 8px 0 24px rgb(0 0 0 / 0.5);
	}
}


// /**
//  * Float element within grid
//  * @param {string} $direction
//  * @param {int} $content_column_count
//  * @param {int} $float_column_count
//  * @param {int} $float_offset_columns
//  */
@mixin grid_float(
	$direction,
	$content_column_count,
	$float_column_count,
	$float_offset_columns: -1
) {
	// TODO: add support for responsive params
	// $content_column_count: (
	// 	md: 8,
	// 	lg: 6,
	// ),
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	$opposite_direction: if($direction == right, left, right);
	
	// Calculate width of floated element
	$float_width: truncate(
		calc(($float_column_count / $content_column_count) * 100%)
	);
	$float_width_factor: truncate(
		calc(($content_column_count - $float_column_count) / $content_column_count)
	);
	
	// TODO: consider removing this auto calculation and making it a required parameter
	// Set float offset automatically when not specified, assuming the content
	// area is centered, and we want to send the floated element all the way to
	// the edge of the grid
	@if $float_offset_columns == -1 {
		$float_offset_columns: math.floor(
			calc(($grid_columns - $content_column_count) / 2)
		);
	}
	
	// What percentage of the content area width is the float offset?
	$float_offset_factor: calc($float_offset_columns / $content_column_count);
	$float_offset_percentage: truncate($float_offset_factor * -100%);
	
	display: block;
	float: $direction;
	width: calc($float_width - (gutter(x) * $float_width_factor));
	margin-#{$opposite_direction}: gutter(x);
	
	// TODO: margin-#{direction} is unneccessary for 12-column container
	margin-#{$direction}: calc($float_offset_percentage - (gutter(x) * truncate($float_offset_factor)));
}
