@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'breakbeat' as b;


// /**
//  * Define column counts
//  * @param {map} $set
//  */
@mixin grid_setup($set) {
	@each $breakpoint, $column_count in $set {
		@include b($breakpoint) {
			grid-template-columns: repeat($column_count, 1fr);
			--grid-items: #{$column_count};
		}
	}
}


@mixin wire_setup($set) {
	@each $breakpoint, $column_count in $set {
		$next_smallest_breakpoint: find_next_smallest_breakpoint(
			map.keys($set), $breakpoint
		);
		@include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
			> :nth-child(#{$column_count}n+1) {
				--wire-end-right: 100%;
				--wire-end-border-left: 0;
			}
			> :nth-child(#{$column_count}n) {
				--wire-end-left: 100%;
				--wire-end-margin-right: 0;
				--wire-end-border-right: 0;
			}
			> :nth-child(#{$column_count}n),
			> :nth-child(#{$column_count}n+1) {
				--wire-end-width: var(--wire-end-width-default);
			}
		}
	}
}


// /**
//  * Define responsive layout
//  * 
//  * For any one item, the parameters can be any combination of:
//  * 6,     // 6 columns wide
//  * 8 3,   // 8 columns wide, starting on column 3
//  * -1,    // Full-width (same as -1 1)
//  * -2 3,  // Start on column 3, end on the second column from the end
//  * r 2,   // 2 rows tall
//  * r 1 4, // 1 row tall, starting on row 4
//  * o -2,  // order -2
//  * 
//  * Parameters must be specified in this order:
//  * - column span [column start]
//  * - row span [row start]
//  * - order
//  * 
//  * Specify parameters for one item using space-delimited lists:
//  * @include layout((
//  *   sm: 6,
//  *   md: 10 1 r 2,
//  *   lg: 8 3,
//  * ));
//  * 
//  * Specify parameters for multiple items, separated by commas:
//  * @include layout((
//  *   sm: (6, 6, 6),
//  *   md: (7 2, 5 r 2, 6 o -2),
//  *   lg: (8, 4),
//  * ));
//  * 
//  * Enabling repeat causes parameters to affect all items, using
//  * multipliers for CSS selectors:
//  * - Repeat off: :nth-child(2)
//  * - Repeat on:  :nth-child(2n)
//  * 
//  * Repeat enabled: odd-numbered items will be 8 columns wide, and
//  * even-numbered items will be 4 columns wide:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: true);
//  * 
//  * Repeat disabled: any items past the second one will not inherit their
//  * settings from smaller breakpoints, or not have any settings:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: false);
//  * 
//  * @param {map} $set
//  * @param {boolean} $repeat
//  * @param {boolean} $self
//  */
@mixin layout($set, $repeat: true, $self: false) {
	$delimiter_row: r;
	$delimiter_order: o;
	
	@each $breakpoint, $elements in $set {
		@if
			meta.type_of($elements) != list
			or list.separator($elements) != comma
		{
			$elements: ($elements,);
		}
		
		// Use next-smallest breakpoint to avoid creating over-zealous item styles
		// that are difficult to override at larger breakpoints
		// TODO: this may be unnecessary for many grid styles, it may be most
		// useful when the number of items in a row is changing and the items on
		// ends of each row have specific styles, such as the wire grid
		$next_smallest_breakpoint: find_next_smallest_breakpoint(
			map.keys($set), $breakpoint
		);
		
		@include b($breakpoint) {
		// @include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
			@for $index from 1 through list.length($elements) {
				$list: list.nth($elements, $index);
				
				// Split params to separate order from column and row
				$split_column_row_order: split_list($list, $delimiter_order);
				$column_row: map.get($split_column_row_order, a);
				$order: map.get($split_column_row_order, b);
				
				// Split params to separate row from column
				$split_column_row: split_list($column_row, $delimiter_row);
				$column: map.get($split_column_row, a);
				$row: map.get($split_column_row, b);
				
				// TODO: if repeat and all elements have the same config, only spit out
				// the rules once
				// Example: sm: (6, 6, 6) => sm: (6)
				
				// TODO: keep track of settings from breakpoint to breakpoint, and if
				// an element uses the same settings as the previous breakpoint, don't
				// repeat those rules
				// Example: (
				//   sm: (6, 4),
				//   md: (6, 3), => Don't repeat rules for first element
				//   lg: (6, 3), => Don't repeat rules for first or second element
				//   xl: (8, 2),
				// )
				
				@if $self {
					// TODO: is there a better way to do this?
					@include grid_plot($column, $row, $order);
				} @else {
					@if $index == 1 and $repeat {
						// TODO: could possibly see how many items there are in the
						// definition and use that to create a selector for the first item
						// that's more like :nth-child(2n+1), so that it doesn't apply to
						// all items in the grid, most of which are then overridden
						> * {
							@include grid_plot($column, $row, $order);
						}
					} @else {
						> :nth-child(#{$index}#{if($repeat, n, '')}) {
							@include grid_plot($column, $row, $order);
						}
					}
				}
			}
		}
	}
}


// /**
//  * Grid plot
//  * @param {int/list} $column
//  * @param {int/list} $row
//  * @param {int} $order
//  */
@mixin grid_plot($column, $row, $order) {
	@if $column {
		@include grid_plot_axis(column, $column);
	}
	@if $row {
		@include grid_plot_axis(row, $row);
	}
	@if $order {
		order: $order;
	}
}


// /**
//  * Grid plot axis
//  * @param {string} $type (row or column)
//  * @param {int/list} $params
//  */
@mixin grid_plot_axis($type, $params) {
	@if 
		meta.type_of($params) == list
		and list.length($params) == 1
	{
		$params: list.nth($params, 1);
	}
	
	$has_start: meta.type_of($params) == list;
	@if $has_start {
		$span: if(list.nth($params, 1) > 0, span, unquote(''));
		grid-#{$type}: list.nth($params, 2) / $span list.nth($params, 1);
		@if $type == column {
			--content-width: #{list.nth($params, 1)};
		}
	} @else {
		$start: if($params > 0, auto, 1);
		$span: if($params > 0, span, unquote(''));
		grid-#{$type}: $start / $span $params;
		@if $type == column {
			--content-width: #{$params};
		}
	}
}


@mixin warning($message) {
	position: relative;
	overflow: auto;
	&::before {
		content: $message;
		position: absolute;
		z-index: 9999;
		left: 12px;
		right: 12px;
		top: 12px;
		padding: 12px 16px;
		border-radius: 8px;
		background: $color_warning;
		box-shadow: 0 8px 24px rgb(0 0 0 / 0.5);
		font-size: 20px;
		color: $color_white;
		text-align: left;
		text-transform: none;
		letter-spacing: normal;
	}
}


// /**
//  * Float element within grid
//  * - Explicit container width
//  * - Optionally implicit float offset
//  * 
//  * @param {string} $direction
//  * @param {int} $in ($container_column_count): Number of columns occupied
//  *   by containing element
//  * @param {int} $width ($float_column_count): Width of floated element
//  * @param {int} $offset ($float_offset_columns): Positive integer, -1 = auto
//  */
@mixin grid_float($direction, $in, $width, $offset: -1) {
	$opposite_direction: if($direction == right, left, right);
	$container_column_count: $in;
	$float_column_count: $width;
	$float_offset_columns: $offset;
	
	// TODO: add support for responsive params
	// $container_column_count: (
	// 	md: 8,
	// 	lg: 6,
	// ),
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	// TODO: $float_offset_columns doesn't really make sense, looks like it might have an off by one error
	
	// Calculate width of floated element
	$float_width: truncate(
		calc(($float_column_count / $container_column_count) * 100%)
	);
	$float_width_factor: truncate(
		calc(($container_column_count - $float_column_count) / $container_column_count)
	);
	
	$gutter_float: gutter(x, $as_list: true);
	$gutter_float_width: list_to_clamp(operate_list($gutter_float, $multiply: $float_width_factor));
	
	float: $direction;
	width: calc($float_width - $gutter_float_width);
	margin-#{$opposite_direction}: gutter(x);
	
	$previous_float_offset_percentage: null;
	$previous_gutter_float_offset: null;
	
	@each $breakpoint, $columns in $grid_columns {
		
		// TODO: consider removing this auto calculation and making it a required parameter
		// Set float offset automatically when not specified, assuming the content
		// area is centered, and we want to send the floated element all the way to
		// the edge of the grid
		@if $float_offset_columns == -1 {
			$float_offset_columns: math.floor(
				calc(($columns - $container_column_count) / 2)
			);
		}
		
		// What percentage of the content area width is the float offset?
		$float_offset_factor: calc($float_offset_columns / $container_column_count);
		$float_offset_percentage: truncate($float_offset_factor * -100%);
		
		$gutter_float_offset: list_to_clamp(operate_list($gutter_float, $multiply: $float_offset_factor));
		
		// Prevent repeating rules
		@if (
			$float_offset_percentage != $previous_float_offset_percentage
			or $gutter_float_offset != $previous_gutter_float_offset
		) {
			@include b($breakpoint) {
				@if not b.b_is_zero($float_offset_percentage) {
					margin-#{$direction}: calc($float_offset_percentage - $gutter_float_offset);
				} @else {
					margin-#{$direction}: 0;
				}
			}
			$previous_float_offset_percentage: $float_offset_percentage;
			$previous_gutter_float_offset: $gutter_float_offset;
		}
	}

}


// /**
//  * Float element within grid
//  * - Implicit container width
//  * - Explicit float offset
//  * 
//  * Advantages over grid_float():
//  * - Don't need to know the width of the floated element's container
//  * - Possibly less generated CSS?
//  * 
//  * Disdvantages:
//  * - Must specify the float offset explicitly
//  * - No automatically extending floated element to edge of grid
//  * 
//  * @param {string/map} $direction
//  * @param {int/map} $width ($float_column_count): Width of floated element
//  * @param {int/map} $offset ($float_offset_columns): Positive integer
//  */
@mixin grid_float_auto_container($direction, $width, $offset: 0) {
	$first_breakpoint_name: list.nth(map.keys($breakpoints), 1);
	
	// Convert single values to maps
	@if meta.type_of($direction) != map {
		$direction: (
			#{$first_breakpoint_name}: $direction,
		);
	}
	@if meta.type_of($width) != map {
		$width: (
			#{$first_breakpoint_name}: $width,
		);
	}
	@if meta.type_of($offset) != map {
		$offset: (
			#{$first_breakpoint_name}: $offset,
		);
	}
	
	$float_column_count: $width;
	$float_offset_columns: $offset;
	
	@each $breakpoint in map.keys($breakpoints) {
		@if
			map.has_key($direction, $breakpoint)
			or map.has_key($float_offset_columns, $breakpoint)
		{
			@include b($breakpoint) {
				@if map.has_key($direction, $breakpoint) {
					$float_direction: map.get($direction, $breakpoint);
					$opposite_direction: if($float_direction == right, left, right);
					float: $float_direction;
					margin-#{$opposite_direction}: gutter(x);
				}
				
				// For every breakpoint that has either a direction or offset specified,
				// we need to update the margins on each side. If a direction or offset
				// is not specified for that breakpoint, use the largest smaller
				// breakpoint that is explicitly defined for that breakpoint.
				$smaller_direction: find_largest_smaller_breakpoint(map.keys($direction), $breakpoint);
				$offset_direction: map.get($direction, $smaller_direction);
				$smaller_offset: find_largest_smaller_breakpoint(map.keys($float_offset_columns), $breakpoint);
				$offset_columns: map.get($float_offset_columns, $smaller_offset);
				
				@if b.b_is_zero($offset_columns) {
					margin-#{$offset_direction}: 0;
				} @else {
					$offset_factor: calc($offset_columns / var(--content-width));
					$offset_percentage: calc(($offset_columns * -100%) / var(--content-width));
					margin-#{$offset_direction}: calc($offset_percentage - (gutter(x) * truncate($offset_factor)));
				}
			}
		}
		
		// Calculate width of floated element
		@if map.has_key($float_column_count, $breakpoint) {
			@include b($breakpoint) {
				$float_columns: map.get($float_column_count, $breakpoint);
				$float_width: calc(($float_columns * 100%) / var(--content-width));
				$float_width_factor: calc(1 - ($float_columns / var(--content-width)));
				width: calc($float_width - (gutter(x) * $float_width_factor));
			}
		}
	}
}


// /**
//  * Create parabolic responsive font sizes
//  * 
//  * Note that this may include an unnecessary media query for the last entry
//  * if it has a fixed value, but we need it there in case the second-to-last
//  * value is also fixed, and therefore doesn't yield a clamp() value that
//  * would obviate the need for another media query.
//  * 
//  * Example input: (
//  *   h1: 56px,
//  *   h2: 36px 48px,
//  *   h3: (
//  *     sm: 24px,
//  *     lg: 32px fixed,
//  *     xl: 36px,
//  *   ),
//  * )
//  * 
//  * @param {map} $font_sizes
//  */
@mixin parabolic_font_sizes($font_sizes) {
	@each $selector, $sizes in $font_sizes {
		#{$selector} {
			
			// Size is formatted as a single value
			// Example: (h1: 24px,)
			@if meta.type_of($sizes) == number {
				font-size: $sizes;
			}
			
			// Sizes are formatted in a list, using default settings for font scaling
			// breakpoints ($font_scale_breakpoint_min, $font_scale_breakpoint_max),
			// or as a map with explicity defined breakpoints
			// Examples: (
			//   h1: 24px 36px,
			//   h2: (
			//     sm: 24px,
			//     md: 32px [fixed],
			//     lg: 36px,
			//   ),
			// ),
			@else {
				@if meta.type_of($sizes) == list {
					$sizes: convert_font_size_list_to_map($sizes);
				}
				
				$sizes: create_intermediate_sizes($sizes);
				$size_count: list.length(map.keys($sizes));
				
				$size_index: 1;
				@each $breakpoint, $size in $sizes {
					@if
						meta.type_of($size) == list
						and list.nth($size, 2) == fixed
					{
						@include b($breakpoint) {
							font-size: list.nth($size, 1);
						}
					}
					
					// Output a basic font size for a single defined breakpoint
					@else if $size_count == 1 {
						@include b($breakpoint) {
							font-size: $size;
						}
					}
					
					// For multiple input sizes, we skip the last entry, because:
					// - its value is already accounted for in the clamp() that starts
					//   with the second-to-last entry and defines a maximum size that is
					//   equal to the size on the largest breakpoint
					// - the size of the last entry is fixed, in which case the it has
					//   already been included by the simple check for fixed values above
					@else if $size_index < $size_count {
						$next_breakpoint: list.nth(map.keys($sizes), $size_index + 1);
						$next_size: list.nth(map.values($sizes), $size_index + 1);
						
						// If size includes any keywords, isolate size value
						@if meta.type_of($next_size) == list {
							$next_size: list.nth($next_size, 1);
						}
						
						$fancy_set: (
							$breakpoint: $size,
							$next_breakpoint: $next_size,
						);
						
						// Use between operator to isolate font sizes to each breakpoint
						// range, rather than overriding them at every breakpoint
						$use_between_operator: false;
						
						// For the first size, since we're using clamp to set the minimum
						// size, which may occur at a breakpoint that's not zero, we should
						// not included a media query
						@if $size_index == 1 {
							font-size: fancy_font_size($fancy_set);
						} @else {
							@if $use_between_operator {
								$next_smallest_breakpoint: find_next_smallest_breakpoint(
									map.keys($sizes), $breakpoint
								);
								@include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
									font-size: fancy_font_size($fancy_set);
								}
							} @else {
								@include b($breakpoint) {
									font-size: fancy_font_size($fancy_set);
								}
							}
						}
					}
					
					$size_index: $size_index + 1;
				}
			}
		}
	}
}
