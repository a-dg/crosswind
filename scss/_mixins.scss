@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// /**
//  * Define column counts
//  * @param {map} $set
//  */
@mixin grid_setup($set) {
	@each $breakpoint, $column_count in $set {
		@include b($breakpoint) {
			grid-template-columns: repeat($column_count, 1fr);
		}
	}
}


// /**
//  * Define responsive layout
//  * 
//  * For any one item, the parameters can be any combination of:
//  * 6,     // 6 columns wide
//  * 8 3,   // 8 columns wide, starting on column 3
//  * r 2,   // 2 rows tall
//  * r 1 4, // 1 row tall, starting on row 4
//  * o -2,  // order -2
//  * 
//  * Parameters must be specified in this order:
//  * - column span [column start]
//  * - row span [row start]
//  * - order
//  * 
//  * Specify parameters for one item using space-delimited lists:
//  * @include layout((
//  *   sm: 6,
//  *   md: 10 1 r 2,
//  *   lg: 8 3,
//  * ));
//  * 
//  * Specify parameters for multiple items, separated by commas:
//  * @include layout((
//  *   sm: (6, 6, 6),
//  *   md: (7 2, 5 r 2, 6 o -2),
//  *   lg: (8, 4),
//  * ));
//  * 
//  * Enabling repeat causes parameters to affect all items, using
//  * multipliers for CSS selectors:
//  * - Repeat off: :nth-child(2)
//  * - Repeat on:  :nth-child(2n)
//  * 
//  * Repeat enabled: odd-numbered items will be 8 columns wide, and
//  * even-numbered items will be 4 columns wide:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: true);
//  * 
//  * Repeat disabled: any items past the second one will not inherit their
//  * settings from smaller breakpoints, or not have any settings:
//  * @include layout((
//  *   lg: (8, 4),
//  * ), $repeat: false);
//  * 
//  * @param {map} $set
//  * @param {boolean} $repeat
//  */
@mixin layout($set, $repeat: true) {
	@each $breakpoint, $elements in $set {
		@if
			meta.type_of($elements) != list
			or list.separator($elements) != comma
		{
			$elements: ($elements,);
		}
		
		@include b($breakpoint) {
			@for $index from 1 through list.length($elements) {
				$list: list.nth($elements, $index);
				
				// Split params to separate order from column and row
				$split_column_row_order: split_list($list, o);
				$column_row: map.get($split_column_row_order, a);
				$order: map.get($split_column_row_order, b);
				
				// Split params to separate row from column
				$split_column_row: split_list($column_row, r);
				$column: map.get($split_column_row, a);
				$row: map.get($split_column_row, b);
				
				// TODO: consider using selector like .i, instead of * and :nth-child
				
				// TODO: if repeat and all elements have the same config, only spit out
				// the rules once
				// Example: sm: (6, 6, 6) => sm: (6)
				
				// TODO: allow defining full-width element without specifying column
				// count, example: sm: (x, 4) or maybe sm: (0, 4)
				@if $index == 1 and $repeat {
					> * {
						@include grid_plot($column, $row, $order);
					}
				} @else {
					> :nth-child(#{$index}#{if($repeat, n, '')}) {
						@include grid_plot($column, $row, $order);
					}
				}
			}
		}
	}
}


@mixin grid_plot($column, $row, $order) {
	@if $column {
		@include grid_plot_axis(column, $column);
	}
	@if $row {
		@include grid_plot_axis(row, $row);
	}
	@if $order {
		order: $order;
	}
}


// /**
//  * Grid plot axis
//  * @param {string} $type (row or column)
//  * @param {int / list} $params
//  */
@mixin grid_plot_axis($type, $params) {
	$has_start: (
		meta.type_of($params) == list
		and list.length($params) > 1
	);
	
	@if $has_start {
		grid-#{$type}: list.nth($params, 2) / span list.nth($params, 1);
	} @else {
		grid-#{$type}: auto / span $params;
	}
}


@mixin warning($message) {
	position: relative;
	overflow: auto;
	&::before {
		content: $message;
		position: absolute;
		z-index: 9999;
		left: 12px;
		top: 12px;
		padding: 24px 28px;
		width: 300px;
		// border: 8px solid #f09;
		border-radius: 24px;
		background: $color_warning;
		font-size: 24px;
		color: #fff;
		box-shadow: 8px 0 24px rgb(0 0 0 / 0.5);
	}
}


// /**
//  * Float element within grid
//  * @param {string} $direction
//  * @param {int} $content_column_count
//  * @param {int} $float_column_count
//  * @param {int} $float_offset_columns
//  */
@mixin grid_float(
	$direction,
	$content_column_count,
	$float_column_count,
	$float_offset_columns: -1
) {
	// TODO: add support for responsive params
	// $content_column_count: (
	// 	md: 8,
	// 	lg: 6,
	// ),
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	$opposite_direction: if($direction == right, left, right);
	
	// Calculate width of floated element
	$float_width: truncate(
		calc(($float_column_count / $content_column_count) * 100%)
	);
	$float_width_factor: truncate(
		calc(($content_column_count - $float_column_count) / $content_column_count)
	);
	
	// TODO: consider removing this auto calculation and making it a required parameter
	// Set float offset automatically when not specified, assuming the content
	// area is centered, and we want to send the floated element all the way to
	// the edge of the grid
	@if $float_offset_columns == -1 {
		$float_offset_columns: math.floor(
			calc(($grid_columns - $content_column_count) / 2)
		);
	}
	
	// What percentage of the content area width is the float offset?
	$float_offset_factor: calc($float_offset_columns / $content_column_count);
	$float_offset_percentage: truncate($float_offset_factor * -100%);
	
	display: block;
	float: $direction;
	width: calc($float_width - (gutter(x) * $float_width_factor));
	margin-#{$opposite_direction}: gutter(x);
	
	// TODO: margin-#{direction} is unneccessary for 12-column container
	margin-#{$direction}: calc($float_offset_percentage - (gutter(x) * truncate($float_offset_factor)));
}
