@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';

// $gutter_type: fixed;
// $gutter_type: stepped;
$gutter_type: flexible;

// $max_width_type: stepped;
$max_width_type: flexible;

@import 'breakbeat';
@import 'functions';
@import 'mixins';
@import 'variables';


* {
	box-sizing: border-box;
  font-family: 'Fatima N', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

body {
	margin: 0;
	padding: 0;
	font-size: 24px;
}

h2 {
	margin: $label_margin;
	padding: $label_padding;
	border-bottom: $label_border_width solid $label_border_color;
	font-weight: 400;
	font-size: 24px;
	text-align: center;
}
span.i-label {
	flex: 1 1 0;
	display: block;
	height: 100%;
	margin: 0;
	padding: $item_label_padding;
	background: $color_pink;
	color: $color_white;
	font-size: 32px;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	text-align: center;
}

.c {
	margin: gutter(y) auto;
	> .c {
		margin: 0 auto;
	}
}

.c-full-width {
}

.c-max-width {
	max-width: $content_max_width;
	
	&.stepped-max-width {
		@each $breakpoint, $width in $breakpoints {
			@if $width == 0 {
				$width: 100%;
			}
			@include b($breakpoint) {
				max-width: $width;
			}
		}
	}
}
.outer-padding {
	padding-left: gutter(outer);
	padding-right: gutter(outer);
}

.g {
	display: grid;
	gap: gutter(x);
	margin: gutter(x) 0;
	// grid-auto-rows: minmax(120px, auto);
	
	.gutter-fixed {
		gap: gutter(x, $gutter_set: $gutter_fixed);
	}
	.gutter-stepped {
		gap: gutter(x, $gutter_set: $gutter_stepped);
	}
	.gutter-flexible {
		gap: gutter(x, $gutter_set: $gutter_flexible);
	}
}

.g-3 {
	@include grid_setup((
		zo: 1,
		md: 3,
	));
}

$grid_setup_4: (
	zo: 1,
	sm: 2,
	av: 3,
	lg: 4,
);
.g-4 {
	@include grid_setup($grid_setup_4);
}

// TODO: any grid that has changes past the max width will either need to
// always be within a full-width container, or will have to have its responsive
// changes past the max width suppressed when it's in a max-width container
.g-6 {
	@include grid_setup((
		zo: 1,
		sm: 2,
		av: 3,
		ch: 4,
		lg: 5,
		yl: 6,
	));
}


.g-auto {
	grid-template-columns: repeat(auto-fill, minmax(200px, auto));
}

// TODO: consider renaming to .i or no name at all, since all children of grids
// might be grid items (or might not, think about this)
.g-item {
	// display: flex; // TODO: this fucks up floating
}


.g-wire {
	$border_color: $color_black;
	$border_width: 1px;
	$content_inset: 10px;
	display: grid;
	gap: 0;
	margin: 0 ($content_inset * -1) $border_width ($content_inset * -1);
	.g-item {
		margin: 0 ($border_width * -1) ($border_width * -1) 0;
		padding: $content_inset;
		border: $border_width solid $border_color;
		position: relative;
		
		&::before,
		&::after {
			position: absolute;
			width: 0;
			height: $border_width;
			background: $border_color;
		}
		&::before {
			top: ($border_width * -1);
		}
		&::after {
			bottom: ($border_width * -1);
		}
	}
	
	&.g-6 {
		.g-item {
			&:nth-child(6n),
			&:nth-child(6n+1) {
				&::before,
				&::after {
					content: '';
					// TODO: use CSS variable to set offset and possibly this whole width
					width: gutter_extended(
						$invert: false,
						$offset: ($content_inset + gutter_max(x))
					);
				}
			}
			&:nth-child(6n) {
				margin-right: 0;
				border-right: none;
				&::before,
				&::after {
					left: 100%;
				}
			}
			&:nth-child(6n+1) {
				border-left: none;
				&::before,
				&::after {
					right: 100%;
				}
			}
		}
	}
	
	.outer-padding & {
		.g-item {
			&:nth-child(6n),
			&:nth-child(6n+1) {
				&::before,
				&::after {
					// TODO: use CSS variable to set offset and possibly this whole width
					width: gutter_extended(
						$invert: false,
						$offset: $content_inset
					);
				}
			}
		}
	}
}

.g-flush {
	$flush_border_width: 2px;
	$flush_border_color: $color_cement;
	
	display: grid;
	margin: 0 0 0 ($flush_border_width * -1);
	overflow: hidden;
	border-top: $flush_border_width solid $flush_border_color;
	
	.g-item {
		margin: ($flush_border_width * -1) ($flush_border_width * -1) 0 0;
		border: $flush_border_width solid $flush_border_color;
		// border-width: 1px 1px 0 0;
		
		/*
		border-width: 0 1px 1px 0;
		
		// Left column
		&:nth-child(2n+1) {
			padding-left: 0;
		}
		
		// Right column
		&:nth-child(2n+2) {
			padding-right: 0;
			border-right: none;
		}
		
		// First row
		&:nth-child(-n+2) {
			padding-top: 0;
		}
		
		// Last row
		&:nth-last-child(-n+2):nth-child(2n+1) {
			&, & ~ div {
				padding-bottom: 0;
				border-bottom: none;
			}
		}
		*/
	}
	span.i-label {
		background: none;
		color: $color_black;
	}
	
	.c-max-width & {
		// @include warning('.g-flush may not be used within .c-max-width, as its container must be allowed to use the full width of the viewport');
		margin-left: 0;
		
		&.g-4 {
			$grid_setup_keys: map.keys($grid_setup_4);
			@each $breakpoint in $grid_setup_keys {
				$next_smallest_breakpoint: find_next_smallest_breakpoint($grid_setup_keys, $breakpoint);
				.g-item {
					@include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
						&:nth-child(#{map.get($grid_setup_4, $breakpoint)}n) {
							margin-right: 0;
						}
					}
				}
			}
		}
		
	}
}


.g-layout {
	grid-template-columns: repeat(calc($grid_columns / 2), 1fr);
	@include b(md) {
		grid-template-columns: repeat($grid_columns, 1fr);
	}
	// TODO: should be like this when $grid_columns is a map
	// @each $breakpoint, $columns in $grid_columns {
	// 	@include b($breakpoint) {
	// 		grid-template-columns: repeat($columns, 1fr);
	// 	}
	// }
}

.g-guide {
	border-bottom: 4px solid $color_black;
	@include b('< md') {
		&:nth-child(6) ~ & {
			display: none;
		}
	}
}


.crazy {
	@include layout((
		zo: (6, 3 r 2, 3 r 3, 3, 2, 2, 2),
		sm: (4, 2 r 2, 2 r 3, 2, 4, 2, 2),
		md: (3, 3 r 2, 3 r 3, 3, 3, 3 r 2, 6),
		av: (3 4 r 3, 6 r 1, 3 r 3, 6 r 2, 6 o -1, 3 4 r 1 o -2, 6 4),
	), $repeat: false);
	
	.g-item {
		&:nth-child(1) .i-label { background: $color_pink; }
		&:nth-child(2) .i-label { background: $color_mint; }
		&:nth-child(3) .i-label { background: $color_purple; }
		&:nth-child(4) .i-label { background: $color_blue; }
		&:nth-child(5) .i-label { background: $color_pink; }
		&:nth-child(6) .i-label { background: $color_purple; }
	}
}


.silly {
	@include layout((
		zo: (2, 2, 4, 4 r 2, 4),
		md: (4, 4, 2 r 3 2, 6 r 2 2, 4),
		av: (-1, 4, 3 r 2 2, 9 r 2 2, 4 o -1),
		ch: (6, 6, 3 r 3, 6 r 3, 3 r 3),
	));
	
	.g-item {
		&:nth-child(1) .i-label { background: $color_pink; }
		&:nth-child(2) .i-label { background: $color_pink; }
		&:nth-child(3) .i-label { background: $color_purple; }
		&:nth-child(4) .i-label { background: $color_blue; }
		&:nth-child(5) .i-label { background: $color_pink; }
	}
}


.col-4-left {
	@include layout((
		zo: 4,
	));
}

.col-6 {
	@include layout((
		zo: 6,
		md: 10 2,
		av: 8 3,
		ch: 6 4,
	));
}

.col-8-4-custom {
	// grid-template-columns: grid_element_width(8, 12) auto;
	
	.g-item {
		&:nth-child(2n) {
			.i-label {
				background: $color_blue;
			}
		}
		
		&.outlier {
			// full width
			@include layout((
				zo: 2,
			), $self: true);
		}
	}
}

.col-6-2-4 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (6, 2, 4),
	));
	
	> :nth-child(1) {
		position: relative;
		z-index: 2;
		left: grid_element_offset(3, 6);
		.i-label {
			background: $color_mint;
			opacity: 0.9;
		}
	}
	> :nth-child(2) {
		.i-label {
			background: $color_blue;
		}
		position: relative;
		// left: grid_element_width(1, 3, $is_negative: false, $include_external_gutter: true);
		
		// left: grid_element_offset(-2, 2);

	}
	> :nth-child(3) {
		position: relative;
		// left: grid_element_offset(-1, 4);
	}
}

.col-8-4 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (8, 4),
		// ch: (9, 3),
		// lg: (10, 2),
	));
	
	> :nth-child(2) {
		// TODO: wtf is this, learn how to use it
		// position: relative;
		// left: grid_element_width(1, 4, $include_external_gutter: true);
	}
	
	&.outlier {
		:nth-child(5) {
			@include layout((
				zo: 6,
				md: 12,
			), $self: true);
		}
	}
	.bogus {
		display: none;
	}
}

.col-9-3 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (8, 4),
		ch: (9, 3),
		// lg: (10, 2),
	));
}

.col-10-2 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (8, 4),
		ch: (9, 3),
		lg: (10, 2),
	));
}

@each $direction in (left, right) {
	.hang-#{string.slice($direction, 1, 1)} {
		margin-#{$direction}: gutter(outer, $invert: true);
		&.hang-extended {
			@include b($content_max_width) {
				margin-#{$direction}: gutter_extended(false);
			}
		}
		&.hang-full {
			@include b($content_max_width) {
				margin-#{$direction}: gutter_extended();
			}
		}
	}
}

.bg {
	padding-top: 30px;
	padding-bottom: 30px;
	background: $color_fog;
}

.f {
	display: flex;
	justify-content: space-between;
	gap: gutter(x);
	padding-top: gutter(y);
	padding-bottom: gutter(y);
}
.f-item {
	flex: 0 1 160px;
}


.g-float {
	@include grid_float(
		$direction: right,
		$content_column_count: 4,
		$float_column_count: 5
	);
	
	.g-item {
		@include layout((
			zo: 4,
			md: 4,
		), $self: true);
	}
	
	+ p {
		margin-top: 0;
		text-align: justify;
		hyphens: auto;
	}
}


.crossing-into-gutter {
	@include layout((
		zo: 6,
	));
	
	// Item crosses gutter to be flush with next
	.g-item {
		&:nth-child(1) {
			margin-right: gutter(x, $invert: true);
		}
	}
	
	// Items meet in the middle of the gutter
	.g-item {
		$gutter_local: gutter(x, $invert: true, $as_list: true);
		$gutter_local: operate_list($gutter_local, $multiply: 0.5);
		&:nth-child(1) {
			margin-right: list_to_clamp($gutter_local);
		}
		&:nth-child(2) {
			margin-left: list_to_clamp($gutter_local);
		}
	}
	
	// Border in middle of gutter
	.g-item {
		$divider_width: 2px;
		$gutter_local: gutter(x, $invert: true, $as_list: true);
		$gutter_local: operate_list(
			$gutter_local,
			$multiply: 0.5,
			$add: ($divider_width * -0.5)
		);
		$gutter_local: list_to_clamp($gutter_local);
		
		&:nth-child(2n-1) {
			position: relative;
			&::after {
				content: '';
				position: absolute;
				right: $gutter_local;
				top: 0;
				width: $divider_width;
				height: 100%;
				background: $color_gray;
			}
		}
	}
	
}
