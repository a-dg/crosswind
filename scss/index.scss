@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// TODO: use @use and make these make sense
@import 'user/general';
@import 'user/grid';
@import 'user/colors';
@import 'user/typography';
@import 'user/demo';

@import 'util/stuff';

@import 'crosswind/functions';
@import 'crosswind/mixins';
@import 'crosswind/grid';
@import 'crosswind/typography';


* {
	box-sizing: border-box;
	font-family: 'Fatima N', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

body {
	margin: 0;
	padding: 0;
	font-size: 24px;
	font-variant-ligatures: none;
}

@include parabolic_font_sizes($all_font_sizes);
// @include parabolic_font_sizes($all_line_heights, 'line-height');

// @debug closest_font_size($all_font_sizes, 32px);





h1 {
	margin: 4em 0 1em 0;
	padding: 0 gutter(outer);
	text-align: center;
}

h2 {
	margin: $label_margin;
	padding: $label_padding;
	border-bottom: $label_border_width solid $label_border_color;
	font-weight: 400;
	// font-size: 24px;
	text-align: center;
}
span.i-label {
	flex: 1 1 0;
	display: block;
	margin: 0;
	padding: $item_label_padding;
	// border: 2px solid $color_pink;
	// border-width: 0 2px;
	background: $color_pink;
	color: $color_white;
	font-size: 32px;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	text-align: center;
}

.c {
	margin: gutter(y) auto;
	> .c {
		margin: 0 auto;
	}
}

.c-full {
}

.c-max {
	max-width: $content_max_width;
	
	&.stepped-max-width {
		@each $breakpoint, $width in $breakpoints {
			@if $width == 0 {
				$width: 100%;
			}
			@include b($breakpoint) {
				max-width: $width;
			}
		}
	}
}
.c-pad {
	padding-left: gutter(outer);
	padding-right: gutter(outer);
}

.g {
	display: grid;
	gap: gutter(x);
	margin: gutter(x) 0;
	// grid-auto-rows: minmax(120px, auto);
	
	.gutter-fixed {
		gap: gutter(x, $gutter_set: $gutter_fixed);
	}
	.gutter-stepped {
		gap: gutter(x, $gutter_set: $gutter_stepped);
	}
	.gutter-flexible {
		gap: gutter(x, $gutter_set: $gutter_flexible);
	}
}

.g-3 {
	@include grid_setup((
		zo: 1,
		md: 3,
	));
}

$grid_setup_4: (
	zo: 1,
	sm: 2,
	av: 3,
	lg: 4,
);
.g-4 {
	@include grid_setup($grid_setup_4);
}

// TODO: any grid that has changes past the max width will either need to
// always be within a full-width container, or will have to have its responsive
// changes past the max width suppressed when it's in a max-width container
.g-6 {
	@include grid_setup((
		zo: 1,
		sm: 2,
		av: 3,
		ch: 4,
		lg: 5,
		yl: 6,
	));
}


.g-auto {
	grid-template-columns: repeat(auto-fill, minmax(200px, auto));
}

.g > * {
	@if $show_item_boundaries {
		outline: 4px dotted $color_mint;
	}
	// display: flex; // TODO: this fucks up floating
}


.g-wire {
	$border_color: $color_black;
	$border_width: 8px;
	$content_inset: gutter(x, $as_list: true); // TODO: make sure you can do this with gutter
	
	$inverted_gutter: if(
		meta.type_of($content_inset) == list,
		list_to_clamp(invert_clamp_list($content_inset)),
		($content_inset * -1)
	);
	
	display: grid;
	gap: 0;
	margin: 0 $inverted_gutter;
	margin-bottom: $border_width;
	
	--wire-end-left: auto;
	--wire-end-right: auto;
	--wire-end-margin-right: #{$border_width * -1};
	--wire-end-border-left: #{$border_width};
	--wire-end-border-right: #{$border_width};
	--wire-end-width: 0;
	--wire-end-width-visible: #{gutter_extended2(
		$invert: false,
		$offset: var(--wire-end-offset)
	)};
	
	// Use a CSS variable to accommodate .c-max and .c-full without
	// having to write explicit styles for both
	// TODO: this removes the -50vw margin built into gutter_extended() but it
	// would be better to have an alternate version that doesn't need that to be
	// removed, perhaps by passing a parameter indicating that we're not trying
	// to compensate for $content_max_width
	--wire-end-offset: 50vw - #{calc(($content_max_width / 2) - list_to_clamp($content_inset))};
	@include b($content_max_width) {
		.c-max & {
			--wire-end-offset: #{list_to_clamp($content_inset)};
		}
	}
	
	> * {
		margin: 0 var(--wire-end-margin-right) ($border_width * -1) 0;
		padding: if(
			meta.type_of($content_inset) == list,
			list_to_clamp($content_inset),
			$content_inset
		);
		border: $border_width solid $border_color;
		border-left-width: var(--wire-end-border-left);
		border-right-width: var(--wire-end-border-right);
		position: relative;
		
		&::before,
		&::after {
			content: '';
			position: absolute;
			left: var(--wire-end-left);
			right: var(--wire-end-right);
			width: var(--wire-end-width);
			height: $border_width;
			background: $border_color;
		}
		&::before {
			top: ($border_width * -1);
		}
		&::after {
			bottom: ($border_width * -1);
		}
	}
	
	&.g-6 {
		@include wire_setup((
			zo: 1,
			sm: 2,
			av: 3,
			ch: 4,
			lg: 5,
			yl: 6,
		));
	}
}


.g-flush {
	$flush_border_width: 2px;
	$flush_border_color: $color_cement;
	
	display: grid;
	margin: 0 0 0 ($flush_border_width * -1);
	overflow: hidden;
	border-top: $flush_border_width solid $flush_border_color;
	
	> * {
		margin: ($flush_border_width * -1) ($flush_border_width * -1) 0 0;
		border: $flush_border_width solid $flush_border_color;
		// border-width: 1px 1px 0 0;
		
		/*
		border-width: 0 1px 1px 0;
		
		// Left column
		&:nth-child(2n+1) {
			padding-left: 0;
		}
		
		// Right column
		&:nth-child(2n+2) {
			padding-right: 0;
			border-right: none;
		}
		
		// First row
		&:nth-child(-n+2) {
			padding-top: 0;
		}
		
		// Last row
		&:nth-last-child(-n+2):nth-child(2n+1) {
			&, & ~ div {
				padding-bottom: 0;
				border-bottom: none;
			}
		}
		*/
	}
	span.i-label {
		background: none;
		color: $color_black;
	}
	
	.c-max & {
		// @include warning('.g-flush may not be used within .c-max, as its container must be allowed to use the full width of the viewport');
		margin-left: 0;
		
		&.g-4 {
			$grid_setup_keys: map.keys($grid_setup_4);
			@each $breakpoint in $grid_setup_keys {
				$next_smallest_breakpoint: find_next_smallest_breakpoint($grid_setup_keys, $breakpoint);
				> * {
					@include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
						&:nth-child(#{map.get($grid_setup_4, $breakpoint)}n) {
							margin-right: 0;
						}
					}
				}
			}
		}
		
	}
}


.g-layout {
	@each $breakpoint, $columns in $grid_columns {
		@include b($breakpoint) {
			grid-template-columns: repeat($columns, 1fr);
		}
	}
}

.g-guide {
	border-bottom: 4px solid $color_black;
	outline: none;
	@include b('< md') {
		&:nth-child(6) ~ & {
			display: none;
		}
	}
}


.crazy {
	grid-auto-rows: minmax(120px, auto);
	@include layout((
		zo: (6, 3 r 2, 3 r 3, 3, 2, 2, 2),
		sm: (4, 2 r 2, 2 r 3, 2, 4, 2, 2),
		md: (3, 3 r 2, 3 r 3, 3, 3, 3 r 2, 6),
		av: (4 4 r 3, 5 r 1, 3 r 3, 5 r 2, 6 o -1, 3 4 r 1 o -2, 6 4),
	), $repeat: false);
	
	> :nth-child(1) .i-label { background: $color_pink; }
	> :nth-child(2) .i-label { background: $color_mint; }
	> :nth-child(3) .i-label { background: $color_purple; }
	> :nth-child(4) .i-label { background: $color_blue; }
	> :nth-child(5) .i-label { background: $color_pink; }
	> :nth-child(6) .i-label { background: $color_purple; }
	
	span.i-label {
		height: 100%;
	}
}


.silly {
	grid-auto-rows: minmax(120px, auto);
	@include layout((
		zo: (2, 2, 4, 4 r 2, 4),
		md: (4, 4, 2 r 3 2, 6 r 2 2, 4),
		av: (-1, 4, 3 r 2 2, 9 r 2 2, 4 o -1),
		ch: (6, 6, 3 r 3, 6 r 3, 3 r 3),
	));
	
	> :nth-child(1) .i-label { background: $color_pink; }
	> :nth-child(2) .i-label { background: $color_pink; }
	> :nth-child(3) .i-label { background: $color_purple; }
	> :nth-child(4) .i-label { background: $color_blue; }
	> :nth-child(5) .i-label { background: $color_pink; }
	
	span.i-label {
		height: 100%;
	}
}


.col-4-left {
	@include layout((
		zo: 4,
	));
}

.col-6 {
	@include layout((
		zo: 6,
		md: 10 2,
		av: 8 3,
		ch: 6 4,
	));
	
	.hang-r {
		@include layout((
			ch: 9 4,
		), $self: true);
	}
	.hang-l {
		@include layout((
			ch: 9,
		), $self: true);
	}
	
	.nine-in-six {
		width: grid_element_width(9, 6);
		#{$content_width_prop}: 9;
	}
	.unhang.six-in-nine {
		// margin: 0 !important;
		width: grid_element_width(6, 9);
		#{$content_width_prop}: 6;
	}
	
	.unhang.six-in-nine.in-ext {
		// margin-right: 
		// width: grid_element_width(6, 9);
		width: auto;
		#{$content_width_prop}: 6;
	}
}

.col-f {
	@include layout((
		zo: -1,
	));
}

.col-8-4-custom {
	// TODO: make this configurable through a mixin
	grid-template-columns: grid_element_width(8, 12) auto;
	
	> :nth-child(2n) {
		.i-label {
			background: $color_blue;
		}
	}
		
	.outlier {
		// full width
		@include layout((
			zo: 2,
		), $self: true);
	}
}

.col-6-2-4 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (6, 2, 4),
	));
	
	> :nth-child(1) {
		position: relative;
		z-index: 2;
		left: grid_element_offset(3, 6);
		
		// TODO: it would be nice if 6 could be --content-width, but right now the
		// element width is used in a SCSS calculation in operate_list(), which is
		// not compatible with CSS variables
		// left: grid_element_offset(3, var(--content-width));
		
		.i-label {
			background: $color_mint;
			opacity: 0.7;
		}
	}
	> :nth-child(2) {
		.i-label {
			background: $color_blue;
		}
		position: relative;
		// left: grid_element_width(1, 3, $is_negative: false, $include_external_gutter: true);
		
		// left: grid_element_offset(-3, 2);

	}
	> :nth-child(3) {
		position: relative;
		// left: grid_element_offset(-1, 4);
	}
}

.col-6-6 {
	@include layout((
		zo: 6,
	));
}

.col-8-4 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (8, 4),
		// ch: (9, 3),
		// lg: (10, 2),
	));
}

.col-9-3 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (8, 4),
		ch: (9, 3),
		// lg: (10, 2),
	));
}

.col-10-2 {
	@include layout((
		zo: (6, 6),
		md: (7, 5),
		av: (8, 4),
		ch: (9, 3),
		lg: (10, 2),
	));
}


// TODO: allow for grid-sized content in any hung element
@each $direction in (left, right) {
	.hang-#{string.slice($direction, 1, 1)} {
		
		// Reverse margin to undo hanging:
		// Hung grid items have negative margin, children of grid items use .unhang
		// to undo hanging by adding back margin
		&.v1 {
			margin-#{$direction}: gutter(outer, $invert: true);
			content: 'narrow';
			.c-max & {
				&.hang-extended {
					.unhang {
						margin-#{$direction}: gutter(outer);
					}
					@include b($content_max_width) {
						margin-#{$direction}: gutter_extended(false);
						content: 'after max width';
						.unhang {
							margin-#{$direction}: gutter_extended(false, false);
							content: 'unhang in extended';
							// padding-#{$direction}: gutter(outer);
						}
					}
				}
				&.hang-full {
					.unhang {
						margin-#{$direction}: gutter(outer);
					}
					@include b($content_max_width) {
						margin-#{$direction}: gutter_extended();
						.unhang {
							margin-#{$direction}: gutter_extended(true, false);
							content: 'this is the one';
						}
					}
				}
				&:not(.hang-extended):not(.hang-full) {
					@include warning('Hanging without .hang-extended or .hang-full probably should not be used within .c-max, as it will only hang into the outer gutter. Consider defining $content_max_width_extended_breakpoint (currently set to "' + $content_max_width_extended_breakpoint + '") and using .hang-extended to extend beyond the outer gutter.');
				}
			}
			
			.c-full & {
				.unhang {
					margin-#{$direction}: gutter(outer);
				}
			}
		}
		
		// Classes on nested child elements:
		// .hang-* classes go on elements inside of grid items, grid item columns
		// remain untouched by negative margins
		// TODO: this method is seemingly "truer" to the grid, in that the grid
		// items themselves don't deviate from the bounds of their respective grid
		// areas, but it might be that we still need to unhang contents of a hung
		// element, which would be quite common
		&.v2 {
			margin-#{$direction}: gutter(outer, $invert: true);
			content: 'narrow v2';
			.c-max & {
				&.hang-extended {
					@include b($content_max_width) {
						margin-#{$direction}: gutter_extended(false);
						content: 'wide v2';
					}
				}
				&.hang-full {
					@include b($content_max_width) {
						margin-#{$direction}: gutter_extended();
					}
				}
				&:not(.hang-extended):not(.hang-full) {
					@include warning('Hanging without .hang-extended or .hang-full probably should not be used within .c-max, as it will only hang into the outer gutter. Consider defining $content_max_width_extended (currently set to ' + $content_max_width_extended + ') and using .hang-extended to extend beyond the outer gutter.');
				}
			}
		}
		
		
	}
}


.unhang {
	background: $color_fog;
}

.hang-content {
	padding: 1em 0;
	background: $color_blue;
}


.bg {
	padding-top: 30px;
	padding-bottom: 30px;
	background: $color_fog;
}

.f {
	display: flex;
	justify-content: space-between;
	gap: gutter(x);
	padding-top: gutter(y);
	padding-bottom: gutter(y);
}
.f-item {
	flex: 0 1 160px;
}


.g-float {
	
	.float-instead-of-hang & {
		box-sizing: content-box;
		padding-right: gutter_extended(true, false);
		background: $color_purple;
		@include grid_float_auto_container(
			// $direction: right,
			$direction: (
				zo: left,
			),
			// $width: 7,
			$width: (
				zo: 6,
				md: 9,
			),
			// $offset: 5
			$offset: (
				md: 0,
			)
		);
	}
	
	.col-6-temp & {
		// Implicit container width, explicit float offset
		@include grid_float_auto_container(
			// $direction: right,
			$direction: (
				tn: left,
				sm: right,
				md: left,
				lg: right,
			),
			// $width: 7,
			$width: (
				tn: 2,
				md: 5,
			),
			// $offset: 5
			$offset: (
				zo: 0,
				av: 2,
				ch: 3,
			)
		);
	}
	
	.col-f & {
		// Explicit container width, optionally implicit float offset
		@include grid_float(
			$direction: right,
			$in: 12,
			$width: 3,
			$offset: 0
		);
	}
	
	.col-4-left & {
		// Explicit container width, optionally implicit float offset
		@include grid_float(
			$direction: right,
			$in: 4,
			$width: 3,
			$offset: 3
		);
	}
	
	+ p {
		margin-top: 0;
		text-align: justify;
		hyphens: auto;
	}
}


.crossing-into-gutter {
	@include layout((
		zo: 6,
	));
	
	// Item crosses gutter to be flush with next
	> :nth-child(1) {
		margin-right: gutter(x, $invert: true);
	}
	
	// Items meet in the middle of the gutter
	$gutter_local: gutter(x, $invert: true, $as_list: true);
	$gutter_local: list_to_clamp(operate_list($gutter_local, $multiply: 0.5));
	> :nth-child(1) {
		margin-right: $gutter_local;
	}
	> :nth-child(2) {
		margin-left: $gutter_local;
	}
	
	// Border in middle of gutter
	$divider_width: 2px;
	$gutter_local: gutter(x, $invert: true, $as_list: true);
	$gutter_local: list_to_clamp(operate_list(
		$gutter_local,
		$multiply: 0.5,
		$add: ($divider_width * -0.5)
	));
	
	> :nth-child(2n-1) {
		position: relative;
		&::after {
			content: '';
			position: absolute;
			right: $gutter_local;
			top: 0;
			width: $divider_width;
			height: 100%;
			background: $color_gray;
		}
	}
	
}


.breakpoint-detector {
	position: fixed;
	left: 0;
	bottom: 0;
	z-index: 10000;
	display: block;
	width: 60px;
	height: 48px;
	padding: 8px 12px;
	background: $color_gray;
	text-align: center;
	color: $color_white;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	
	span {
		display: none;
		@each $breakpoint in map.keys($breakpoints) {
			@include b('= #{$breakpoint}') {
				&.#{$breakpoint} {
					display: block;
				}
			}
		}
	}
}

.breakpoint-scale {
	$line_height: 20px;
	overflow: hidden;
	div {
		position: relative;
		margin: 2px 0;
		padding: 0 8px;
		height: $line_height;
		background: $color_cement;
		font-size: 14px;
		text-transform: uppercase;
		letter-spacing: 0.05em;
		
		&::after {
			content: '';
			position: absolute;
			right: 0;
			top: 0;
			display: block;
			height: 0;
			border-top: ($line_height - 1px) solid $color_white;
			border-left: 1px solid transparent;
		}
	}
	
	@each $key, $value in $breakpoints {
		$current_index: list.index(map.keys($breakpoints), $key);
		$next_index: $current_index + 1;
		@if $next_index > list.length(map.keys($breakpoints)) {
			$next_index: $current_index;
		}
		$next_size: list.nth(map.values($breakpoints), $next_index);
		$wedge_width: $next_size - $value;
		
		.#{$key} {
			width: $next_size;
			@include b('= #{$key}') {
				background: $color_mint;
			}
			&::after {
				border-left-width: $wedge_width;
			}
		}
	}
}
