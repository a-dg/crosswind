@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'breakbeat' as b;


// TODO: keep clamp values separated as long as possible, so they can be used
// individually for calculations (or figure out how to separate them)

// /**
//  * Get gutter width
//  * @param {string} $property: x, y, outer
//  * @param {boolean} $invert
//  * @param {boolean} $as_list
//  * @param {map} $gutter_set
//  * @return {number/calculation}
//  */
@function gutter($property, $invert: false, $as_list: false, $gutter_set: $gutter) {
	$gutter_value: map.get($gutter_set, $property);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if $as_list {
		@if not $invert {
			@return $gutter_value;
		}
		
		@return invert_clamp_list($gutter_value);
	}
	
	@if not $invert {
		@return list_to_clamp($gutter_value);
	}
	
	// TODO: find all cases where performing calculations on the result of gutter()
	// and refactor to perform calculations on individual values
	
	$gutter_value: invert_clamp_list($gutter_value);
	@return list_to_clamp($gutter_value);
}


// /**
//  * Invert and reverse list of arguments for clamp()
//  * @param {list} $list
//  * @return {list}
//  */
@function invert_clamp_list($list) {
	$result: reverse_list($list);
	@return invert_list($result);
}


// /**
//  * Invert all values in list
//  * @param {list} $list
//  * @return {list}
//  */
@function invert_list($list) {
	$separator: list.separator($list);
	$result: ();
	@each $value in $list {
		$result: list.append($result, ($value * -1), $separator);
	}
	@return $result;
}


// /**
//  * Reverse list
//  * @link https://kittygiraudel.com/2013/08/08/advanced-sass-list-functions/
//  * @param {list} $list
//  * @param {boolean} $recursive
//  * @return {list}
//  */
@function reverse_list($list, $recursive: false) {
	$separator: list.separator($list);
  $result: ();
	
  @for $i from (list.length($list) * -1) through -1 {
    @if
			$recursive
			and meta.type_of(list.nth($list, math.abs($i))) == list
		{
      $result: list.append(
				$result,
				reverse_list(list.nth($list, math.abs($i)), $recursive),
				$separator
			);
    } @else {
      $result: list.append($result, list.nth($list, math.abs($i)), $separator);
    }
  }
	
  @return $result;
}


// /**
//  * Convert three-element list to clamp(), or return first element
//  * @param {list} $list
//  * @return {calculation}
//  */
@function list_to_clamp($list) {
	@if meta.type_of($list) != list {
		@return $list;
	}
	
	@if list.length($list) != 3 {
		@error 'List passed to list_to_clamp() was not three elements: ' + $list;
		@return list.nth($list, 1);
	}
	
	@return clamp(
		list.nth($list, 1),
		list.nth($list, 2),
		list.nth($list, 3)
	);
}


// /**
//  * Get max gutter width
//  * @param {string} $type
//  * @param {boolean} $invert
//  * @return {number/string}
//  */
@function gutter_max($type, $invert: false) {
	$gutter_value: map.get($gutter, $type);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return list.nth($gutter_value, 3);
	}
	
	@return (list.nth($gutter_value, 3) * -1);
}


// /**
//  * Get gutter value for extending beyond max width, either to edge of
//  * viewport or stopping at $gutter_base_outer_extended
//  * 
//  * Alternate expressions:
//  * - calc(((100vw - ($content_max_width - (gutter_max(x) * 2))) / -2));
//  * - calc(((100vw - $content_max_width) / -2) - gutter_max(x));
//  * 
//  * @param {boolean} $to_viewport_edge
//  * @param {boolean} $invert
//  * @param {number} $offset
//  * @return {string}
//  */
@function gutter_extended($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	@if $to_viewport_edge {
		@return calc(
			(50vw * $inversion)
			- (
				(($content_max_width / 2) - gutter_max(x) + $offset)
				* $inversion
			)
		);
	}
	
	// TODO: check this with all gutter types
	// TODO: does not use $content_max_width_extended?
	@return clamp(
		($gutter_base_outer_extended * -1),
		calc((50vw * $inversion) + (($content_max_width / 2) - gutter_max(x) + $offset)),
		(gutter_max(x) * -1)
	);
}


// TODO: make this work with $grid_columns as map
// /**
//  * Calculate width of element within grid system
//  * 
//  * Usage:
//  * margin-right: grid_element_width(
//  *   1, 3, $gutter_base_x, $include_external_gutter: true
//  * );
//  * 
//  * @param {int} $column_span: Number of columns to shift
//  * @param {int} $total_columns: Number of columns already occupied by element
//  * @param {number} $gutter_width
//  * @param {boolean} $is_negative
//  * @param {boolean} $include_external_gutter: Sometimes it's necessary to
//  *   include one more gutter in addition to the ones in between the columns
//  * @return {type}
//  */
@function grid_element_width(
	$column_span,
	$total_columns,
	$gutter_width: gutter(x, $as_list: true),
	$is_negative: false,
	$include_external_gutter: false
) {
	
	// TODO: none of this math works when CSS variables are used
	
	// TODO: values are truncated too early
	
	// Example gutter width:
	// $gutter_width: 16px, 4.16vw, 48px
	
	// Width of all gutters combined (fixed: px; flexible: clamp(px, vw, px))
	// $total_gutter_width: calc(($total_columns - 1) * $gutter_width);
	$total_gutter_width: operate_list($gutter_width, $multiply: ($total_columns - 1));
	// 176px, 45.76vw, 528px
	
	// Share of width occupied by spanned columns (float)
	$multiplier: calc($column_span / $total_columns);
	// 0.666666
	
	// Width remaining for spanned columns after gutters have been removed (% + px)
	$remaining_column_space: truncate(100% * $multiplier);
	// 66.6666%
	
	$remaining_gutter_space: truncate(operate_list($total_gutter_width, $multiply: $multiplier));
	// 117.3333px, 30.5066vw, 352px
	
	// Width of gutters between spanned columns, plus optionally one more
	// (fixed: px; flexible: clamp(px, vw, px))
	$spanned_gutter_space: operate_list(
		$gutter_width,
		$multiply: ($column_span - if($include_external_gutter, 0, 1))
	);
	// 112px, 29.12vw, 336px
	
	$gutter_remainder: list_to_clamp(
		subtract_lists($remaining_gutter_space, $spanned_gutter_space)
	);
	
	@if $is_negative {
		// TODO: don't know if this works yet
		@return calc(($remaining_column_space * -1) - $gutter_remainder);
	}
	
	@return calc($remaining_column_space - $gutter_remainder);
}


// TODO: make this work with $offset_columns and $element_columns as map
// /**
//  * Calculate offset of element within grid system
//  * @param {int} $offset_columns: Number of columns to shift
//  * @param {int} $element_columns: Element width in columns
//  * @param {number} $gutter_width
//  * @return {calculation}
//  */
@function grid_element_offset(
	$offset_columns,
	$element_columns,
	$gutter_width: gutter(x, $as_list: true)
) {
	$multiplier: calc($offset_columns / $element_columns);
	$offset_percent: truncate(100% * $multiplier);
	$offset_gutter: operate_list($gutter_width, $multiply: $multiplier);
	
	@if $offset_columns < 0 {
		$offset_gutter: invert_list($offset_gutter);
		@return calc($offset_percent - list_to_clamp($offset_gutter));
	}
	
	@return calc($offset_percent + list_to_clamp($offset_gutter));
}


// /**
//  * Add elements from two lists
//  * @param {list} $a
//  * @param {list} $b
//  * @return {list}
//  */
@function add_lists($a, $b) {
	@return combine_lists($a, $b, '+');
}


// /**
//  * Subtract elements from two lists
//  * @param {list} $a
//  * @param {list} $b
//  * @return {list}
//  */
@function subtract_lists($a, $b) {
	@return combine_lists($a, $b, '-');
}


// /**
//  * Perform calculation on two lists
//  * @param {list} $a
//  * @param {list} $b
//  * @param {string} $operator
//  * @return {list}
//  */
@function combine_lists($a, $b, $operator) {
	@if
		meta.type_of($a) != list
		and meta.type_of($b) != list
	{
		@return operate($a, $b, $operator);
	}
	
	@if list.length($a) != list.length($b) {
		@error 'Lists passed to combine_lists() must be of same length';
	}
	
	$separator: list.separator($a);
	$result: ();
	$index: 1;
	@each $a_item in $a {
		$b_item: list.nth($b, $index);
		$item_result: operate($a_item, $b_item, $operator);
		$result: list.append($result, $item_result, $separator);
		$index: $index + 1;
	}
	@return $result;
}


// /**
//  * Perform calculation on two values
//  * @param {number} $a
//  * @param {number} $b
//  * @param {string} $operator
//  * @return {number}
//  */
@function operate($a, $b, $operator) {
	$result: 0;
	@if $operator == '+' {
		$result: ($a + $b);
	} @else if $operator == '-' {
		$result: ($a - $b);
	} @else if $operator == '*' {
		$result: ($a * $b);
	} @else if $operator == '/' {
		$result: calc($a / $b);
	}
	@return $result;
}


// /**
//  * Peform calculation on each element in list
//  * @param {list} $list
//  * @param {number} $multiply
//  * @param {number} $add
//  * @return {list}
//  */
@function operate_list($list, $multiply: 1, $add: 0) {
	@if meta.type_of($list) != list {
		$list: ($list,);
	}
	
	$separator: list.separator($list);
	$result: ();
	@each $value in $list {
		$unit: math.unit($value);
		$list_item_result: $value;
		@if $multiply != 1 {
			$list_item_result: ($list_item_result * $multiply);
		}
		@if not b.b_is_zero($add) {
			$list_item_result: calc($list_item_result + $add);
		}
		$result: list.append(
			$result,
			$list_item_result,
			$separator
		);
	}
	@return $result;
}


// /**
//  * Round number to nearest multiple of 2
//  * @param {number} $value
//  * @return {int}
//  */
@function round_even($value) {
  @return (math.round(calc($value / 2)) * 2);
}


// /**
//  * Round number to nearest multiple of 4
//  * @param {number} $value
//  * @return {int}
//  */
@function round_four($value) {
  @return (math.round(calc($value / 4)) * 4);
}


// /**
//  * Is this value a percentage?
//  * @param {number} $value
//  * @return {boolean}
//  */
@function is_percent($value) {
  @return math.unit($value) == '%';
}


// /**
//  * Truncate decimal to specified number of places
//  * @param {number/list} $value
//  * @param {int} $places
//  * @return {number}
//  */
@function truncate($value, $places: 4) {
	@return $value;
	
	// TODO: verify that flooring does not cause elements to accidentally reflow
	// when using negative numbers
	
	@if meta.type_of($value) == list {
		$separator: list.separator($value);
		$result: ();
		@each $list_item in $value {
			$result: list.append($result, truncate($list_item), $separator);
		}
		@return $result;
	}
	
	@return calc(math.floor($value * math.pow(10, $places)) / math.pow(10, $places));
}


// /**
//  * Replace in string
//  * @param {string} $input
//  * @param {string} $search
//  * @param {string} $replace
//  * @return {string}
//  */
@function replace($input, $search, $replace: '') {
  $index: string.index($input, $search);
  @if not $index {
		@return $input;
	}
	
	@return string.slice($input, 1, $index - 1) + $replace + replace(
		string.slice($input, $index + string.length($search)), $search, $replace
	);
}


// /**
//  * Find next smallest breakpoint for range
//  * 
//  * Start with a breakpoint in a subset of breakpoints, find the next
//  * breakpoint in the subset, then find next smallest breakpoint in all
//  * breakpoints. This is useful for creating a media query where you don't
//  * want to define unique (and perhaps redundant) parameters for every
//  * single breakpoint.
//  * 
//  * For example, if complex grid styles are too tedious to override
//  * using ">=" media queries, it's better to use "=" media queries. However,
//  * all parameters for the grid must be explicitly defined for every
//  * breakpoint, even if they don't change at every breakpoint, because they
//  * won't be inherited from smaller breakpoints. With this function, it's
//  * possible to define only non-redundant parameters, and create range
//  * breakpoints (using the "><" operator). This simplifies configuration and
//  * reduces the number of media queries required.
//  * 
//  * Example:
//  * - All breakpoints: sm, md, lg, xl, xxl
//  * - Subset: sm, xl, xxl
//  * - Next smallest breakpoint for "sm" in subset: lg (one down from xl)
//  * 
//  * @param {list} $breakpoint_subset_keys
//  * @param {string} $breakpoint
//  * @return {string}
//  */
@function find_next_smallest_breakpoint($breakpoint_subset_keys, $breakpoint) {
	$all_breakpoint_keys: map.keys($breakpoints);
	
	$current_subset_index: list.index($breakpoint_subset_keys, $breakpoint);
	$next_subset_index: math.min(($current_subset_index + 1), list.length($breakpoint_subset_keys));
	$next_subset_breakpoint: list.nth($breakpoint_subset_keys, $next_subset_index);
	@if $next_subset_breakpoint == $breakpoint {
		@return list.nth($all_breakpoint_keys, list.length($all_breakpoint_keys));
	}
	
	$next_all_index: list.index($all_breakpoint_keys, $next_subset_breakpoint);
	$next_smallest_index: math.max(1, $next_all_index - 1);
	$next_smallest_breakpoint: list.nth($all_breakpoint_keys, $next_smallest_index);
	@return $next_smallest_breakpoint;
}


// /**
//  * Split list at first occurrence of delimiter
//  * @param {list} $input
//  * @param {string} $delimiter
//  * @return {map}
//  */
@function split_list($input, $delimiter) {
	@if
		type_of($input) != list
		or not list.index($input, $delimiter)
	{
		@return (
			a: $input,
			b: null,
		);
	}
	
	$list_a: ();
	$list_b: ();
	$is_before_split: true;
	
	@each $item in $input {
		@if $item == $delimiter {
			$is_before_split: false;
		} @else {
			@if $is_before_split {
				$list_a: list.append($list_a, $item, $separator: space);
			} @else {
				$list_b: list.append($list_b, $item, $separator: space);
			}
		}
	}
	
	// TODO: consider this method of splitting lists
	// $list: 3 4 r 1 o -2;
	// $string: meta.inspect($list);
	// $split_list: string.split($string, o);
	// @debug $split_list;
	// @debug meta.type_of($split_list);
	
	@return (
		a: $list_a,
		b: $list_b,
	);
}
