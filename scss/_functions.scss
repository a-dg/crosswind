@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// /**
//  * Get gutter width
//  * @param {string} $property: x, y, outer
//  * @param {boolean} $invert
//  * @param {map} $gutter_set
//  * @return {number/string}
//  */
@function gutter($property, $invert: false, $gutter_set: $gutter) {
	$gutter_value: map.get($gutter_set, $property);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return clamp(
			list.nth($gutter_value, 1),
			list.nth($gutter_value, 2),
			list.nth($gutter_value, 3)
		);
	}
	
	@return clamp(
		(list.nth($gutter_value, 3) * -1),
		(list.nth($gutter_value, 2) * -1),
		(list.nth($gutter_value, 1) * -1)
	);
}


// /**
//  * Get max gutter width
//  * @param {string} $type
//  * @param {boolean} $invert
//  * @return {number/string}
//  */
@function gutter_max($type, $invert: false) {
	$gutter_value: map.get($gutter, $type);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return list.nth($gutter_value, 3);
	}
	
	@return (list.nth($gutter_value, 3) * -1);
}


// /**
//  * Get gutter value for extending beyond max width, either to edge of
//  * viewport or stopping at $gutter_base_outer_extended
//  * 
//  * Alternate expressions:
//  * - calc(((100vw - ($content_max_width - (gutter_max(x) * 2))) / -2));
//  * - calc(((100vw - $content_max_width) / -2) - gutter_max(x));
//  * 
//  * @param {boolean} $to_viewport_edge
//  * @param {boolean} $invert
//  * @param {number} $offset
//  * @return {string}
//  */
@function gutter_extended($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	@if $to_viewport_edge {
		@return calc(
			(50vw * $inversion)
			- (
				(($content_max_width / 2) - gutter_max(x) + $offset)
				* $inversion
			)
		);
	}
	
	// TODO: check this with all gutter types
	// TODO: does not use $content_max_width_extended?
	@return clamp(
		($gutter_base_outer_extended * -1),
		calc((50vw * $inversion) + (($content_max_width / 2) - gutter_max(x) + $offset)),
		(gutter_max(x) * -1)
	);
}


// TODO: make this work with $grid_columns as map
// /**
//  * Calculate width of element within grid system
//  * 
//  * Usage:
//  * margin-right: grid_element_width(
//  *   3, 1, $gutter_base_x, $include_external_gutter: true
//  * );
//  * 
//  * @param {int} $total_columns
//  * @param {int} $column_span
//  * @param {number} $gutter_width
//  * @param {boolean} $is_negative
//  * @param {boolean} $include_external_gutter
//  * @return {type}
//  */
@function grid_element_width(
	$total_columns: $grid_columns,
	$column_span,
	$gutter_width,
	$is_negative: false,
	$include_external_gutter: false
) {
	// Sometimes it's necessary to include one more gutter in addition to the
	// ones in between the columns
	// $include_external_gutter: false;
	
	// TODO: none of this math works when clamp() or CSS variables are used
	
	// Width of all gutters combined (px)
	$total_gutter_width: (($total_columns - 1) * $gutter_width);
	
	// Share of width occupied by spanned columns (float)
	$multiplier: calc($column_span / $total_columns);
	
	// Width remaining for spanned columns after gutters have been removed (% + px)
	$remaining_column_space: truncate(100% * $multiplier);
	$remaining_gutter_space: truncate($total_gutter_width * $multiplier);
	
	// Width of gutters between spanned columns, plus optionally one more (px)
	$total_gutter_space: ($gutter_width * ($column_span - if($include_external_gutter, 0, 1)));
	
	@return if($is_negative,
		calc(($remaining_column_space + ($total_gutter_space - $remaining_gutter_space)) * -1),
		calc($remaining_column_space + ($total_gutter_space - $remaining_gutter_space))
	);
}


// /**
//  * Round number to nearest multiple of 2
//  * @param {number} $value
//  * @return {int}
//  */
@function round_even($value) {
  @return (math.round(calc($value / 2)) * 2);
}


// /**
//  * Round number to nearest multiple of 4
//  * @param {number} $value
//  * @return {int}
//  */
@function round_four($value) {
  @return (math.round(calc($value / 4)) * 4);
}


// /**
//  * Is this value a percentage?
//  * @param {number} $value
//  * @return {boolean}
//  */
@function is_percent($value) {
  @return math.unit($value) == '%';
}


// /**
//  * Truncate decimal to specified number of places
//  * @param {number} $value
//  * @param {int} $places
//  * @return {number}
//  */
@function truncate($value, $places: 4) {
	// TODO: verify that flooring does not cause elements to accidentally reflow
	// when using negative numbers
	@return calc(math.floor($value * math.pow(10, $places)) / math.pow(10, $places));
}


// /**
//  * Replace in string
//  * @param {string} $input
//  * @param {string} $search
//  * @param {string} $replace
//  * @return {string}
//  */
@function replace($input, $search, $replace: '') {
  $index: string.index($input, $search);
  @if not $index {
		@return $input;
	}
	
	@return string.slice($input, 1, $index - 1) + $replace + replace(
		string.slice($input, $index + string.length($search)), $search, $replace
	);
}


// /**
//  * Find next smallest breakpoint for range
//  * 
//  * Start with a breakpoint in a subset of breakpoints, find the next
//  * breakpoint in the subset, then find next smallest breakpoint in all
//  * breakpoints. This is useful for creating a media query where you don't
//  * want to define unique (and perhaps redundant) parameters for every
//  * single breakpoint.
//  * 
//  * For example, if complex grid styles are too tedious to override
//  * using ">=" media queries, it's better to use "=" media queries. However,
//  * all parameters for the grid must be explicitly defined for every
//  * breakpoint, even if they don't change at every breakpoint, because they
//  * won't be inherited from smaller breakpoints. With this function, it's
//  * possible to define only non-redundant parameters, and create range
//  * breakpoints (using the "><" operator). This simplifies configuration and
//  * reduces the number of media queries required.
//  * 
//  * Example:
//  * - All breakpoints: sm, md, lg, xl, xxl
//  * - Subset: sm, xl, xxl
//  * - Next smallest breakpoint for "sm" in subset: lg (one down from xl)
//  * 
//  * @param {list} $breakpoint_subset_keys
//  * @param {string} $breakpoint
//  * @return {string}
//  */
@function find_next_smallest_breakpoint($breakpoint_subset_keys, $breakpoint) {
	$all_breakpoint_keys: map.keys($breakpoints);
	
	$current_subset_index: list.index($breakpoint_subset_keys, $breakpoint);
	$next_subset_index: math.min(($current_subset_index + 1), list.length($breakpoint_subset_keys));
	$next_subset_breakpoint: list.nth($breakpoint_subset_keys, $next_subset_index);
	@if $next_subset_breakpoint == $breakpoint {
		@return list.nth($all_breakpoint_keys, list.length($all_breakpoint_keys));
	}
	
	$next_all_index: list.index($all_breakpoint_keys, $next_subset_breakpoint);
	$next_smallest_index: math.max(1, $next_all_index - 1);
	$next_smallest_breakpoint: list.nth($all_breakpoint_keys, $next_smallest_index);
	@return $next_smallest_breakpoint;
}


// /**
//  * Split list at first occurrence of delimiter
//  * @param {list} $input
//  * @param {string} $delimiter
//  * @return {map}
//  */
@function split_list($input, $delimiter) {
	@if
		type_of($input) != list
		or not list.index($input, $delimiter)
	{
		@return (
			a: $input,
			b: null,
		);
	}
	
	$list_a: ();
	$list_b: ();
	$is_before_split: true;
	
	@each $item in $input {
		@if $item == $delimiter {
			$is_before_split: false;
		} @else {
			@if $is_before_split {
				$list_a: list.append($list_a, $item, $separator: space);
			} @else {
				$list_b: list.append($list_b, $item, $separator: space);
			}
		}
	}
	
	// TODO: consider this method of splitting lists
	// $list: 3 4 r 1 o -2;
	// $string: meta.inspect($list);
	// $split_list: string.split($string, o);
	// @debug $split_list;
	// @debug meta.type_of($split_list);
	
	@return (
		a: $list_a,
		b: $list_b,
	);
}
