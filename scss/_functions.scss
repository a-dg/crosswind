@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';


// /**
//  * Get gutter width
//  * @param {string} $type
//  * @param {boolean} $invert
//  * @return {number/string}
//  */
@function gutter($type, $invert: false) {
	$gutter_value: map.get($gutter, $type);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return clamp(
			list.nth($gutter_value, 1),
			list.nth($gutter_value, 2),
			list.nth($gutter_value, 3)
		);
	}
	
	@return clamp(
		(list.nth($gutter_value, 3) * -1),
		(list.nth($gutter_value, 2) * -1),
		(list.nth($gutter_value, 1) * -1)
	);
}


// /**
//  * Get max gutter width
//  * @param {string} $type
//  * @param {boolean} $invert
//  * @return {number/string}
//  */
@function gutter_max($type, $invert: false) {
	$gutter_value: map.get($gutter, $type);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return list.nth($gutter_value, 3);
	}
	
	@return (list.nth($gutter_value, 3) * -1);
}


// /**
//  * Get gutter value for extending beyond max width, either to edge of
//  * viewport or stopping at $gutter_base_outer_extended
//  * 
//  * Alternate expressions:
//  * - calc(((100vw - ($content_max_width - (gutter_max(x) * 2))) / -2));
//  * - calc(((100vw - $content_max_width) / -2) - gutter_max(x));
//  * 
//  * @param {boolean} $to_viewport_edge
//  * @param {boolean} $invert
//  * @param {number} $offset
//  * @return {string}
//  */
@function gutter_extended($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	@if $to_viewport_edge {
		@return calc((50vw * $inversion) - (
			(($content_max_width / 2) - gutter_max(x) + $offset) * $inversion)
		);
	}
	
	// TODO: check this with all gutter types
	// TODO: does not use $content_max_width_extended?
	@return clamp(
		($gutter_base_outer_extended * -1),
		calc((50vw * $inversion) + (($content_max_width / 2) - gutter_max(x) + $offset)),
		(gutter_max(x) * -1)
	);
}


// /**
//  * Calculate width of element within grid system
//  * 
//  * Usage:
//  * margin-right: grid_element_width(
//  *   3, 1, $gutter_base_x, $include_external_gutter: true
//  * );
//  * 
//  * @param {int} $total_columns
//  * @param {int} $column_span
//  * @param {number} $gutter_width
//  * @param {boolean} $is_negative
//  * @param {boolean} $include_external_gutter
//  * @return {type}
//  */
@function grid_element_width(
	$total_columns: $grid_columns,
	$column_span,
	$gutter_width,
	$is_negative: false,
	$include_external_gutter: false
) {
	// Sometimes it's necessary to include one more gutter in addition to the
	// ones in between the columns
	// $include_external_gutter: false;
	
	// TODO: none of this math works when clamp() or CSS variables are used
	
	// Width of all gutters combined (px)
	$total_gutter_width: (($total_columns - 1) * $gutter_width);
	
	// Share of width occupied by spanned columns (float)
	$multiplier: calc($column_span / $total_columns);
	
	// Width remaining for spanned columns after gutters have been removed (% + px)
	$remaining_column_space: truncate(100% * $multiplier);
	$remaining_gutter_space: truncate($total_gutter_width * $multiplier);
	
	// Width of gutters between spanned columns, plus optionally one more (px)
	$total_gutter_space: ($gutter_width * ($column_span - if($include_external_gutter, 0, 1)));
	
	@return if($is_negative,
		calc(($remaining_column_space + ($total_gutter_space - $remaining_gutter_space)) * -1),
		calc($remaining_column_space + ($total_gutter_space - $remaining_gutter_space))
	);
}


// /**
//  * Round number to nearest multiple of 2
//  * @param {number} $value
//  * @return {int}
//  */
@function round_even($value) {
  @return (math.round(calc($value / 2)) * 2);
}


// /**
//  * Round number to nearest multiple of 4
//  * @param {number} $value
//  * @return {int}
//  */
@function round_four($value) {
  @return (math.round(calc($value / 4)) * 4);
}


// /**
//  * Is this value a percentage?
//  * @param {number} $value
//  * @return {boolean}
//  */
@function is_percent($value) {
  @return math.unit($value) == '%';
}


// /**
//  * Truncate decimal to specified number of places
//  * @param {number} $value
//  * @param {int} $places
//  * @return {number}
//  */
@function truncate($value, $places: 4) {
	// TODO: verify that flooring does not cause elements to accidentally reflow
	// when using negative numbers
	@return calc(math.floor($value * math.pow(10, $places)) / math.pow(10, $places));
}


// /**
//  * Replace in string
//  * @param {string} $input
//  * @param {string} $search
//  * @param {string} $replace
//  * @return {string}
//  */
@function replace($input, $search, $replace: '') {
  $index: string.index($input, $search);
  @if not $index {
		@return $input;
	}
	
	@return string.slice($input, 1, $index - 1) + $replace + replace(
		string.slice($input, $index + string.length($search)), $search, $replace
	);
}


// /**
//  * Split list
//  * @param {list} $input
//  * @param {string} $delimiter
//  * @return {map}
//  */
@function split_list($input, $delimiter) {
	@if
		type_of($input) != list
		or not list.index($input, $delimiter)
	{
		@return (
			a: $input,
			b: null,
		);
	}
	
	$list_a: ();
	$list_b: ();
	$is_before_split: true;
	
	@each $item in $input {
		@if $item == $delimiter {
			$is_before_split: false;
		} @else {
			@if $is_before_split {
				$list_a: list.append($list_a, $item, $separator: space);
			} @else {
				$list_b: list.append($list_b, $item, $separator: space);
			}
		}
	}
	
	// TODO: consider this method of splitting lists
	// $list: 3 4 r 1 o -2;
	// $string: meta.inspect($list);
	// $split_list: string.split($string, o);
	// @debug $split_list;
	// @debug meta.type_of($split_list);
	
	@return (
		a: $list_a,
		b: $list_b,
	);
}
