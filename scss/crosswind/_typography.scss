// @use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';

@use 'util';
@use '../lib/breakbeat' as *;

@use '../config';
@use 'grid';


/// Fancy font size
/// 
/// Usage for linear scaling:
/// font-size: _fancy_font_size((
///   sm: 24px,
///   xl: 72px,
/// ));
/// 
/// For non-linear scaling, use parabolic_font_sizes()
/// 
/// @param {map} param
/// @return {number | calculation} Fixed size or clamp()
@function _fancy_font_size($set) {
	$min: list.nth(map.values($set), 1);
	@if list.length(map.values($set)) == 1 {
		@return $min;
	}
	
	$max: list.nth(map.values($set), 2);
	$start: map.get($breakpoints, list.nth(map.keys($set), 1));
	$end: map.get($breakpoints, list.nth(map.keys($set), 2));
	
	$size_fixed: calc(($max - $min) / ($end - $start));
	@if $size_fixed == 0 {
		@return $min;
	}
	
	$size_fluid: ($size_fixed * 100vw);
	$size_preferred: calc(util.trunx($size_fluid) + util.trunx($min - ($size_fixed * $start)));
	
	@if $min > $max {
		$min_swap: $min;
		$min: $max;
		$max: $min_swap;
	}
	
	@return clamp($min, $size_preferred, $max);
}


/// Convert two-item list to map, using default font scaling breakpoints
/// @param {list} $sizes
/// @return {map} *
@function _convert_font_size_list_to_map($sizes) {
	@return (
		config.$font_scale_breakpoint_min: list.nth($sizes, 1),
		config.$font_scale_breakpoint_max: list.nth($sizes, 2),
	);
}


/// Find closest font size to target
/// @param {map} $set
/// @param {number} $target_size
/// @return {map} *
@function closest_font_size($set, $target_size) {
	
	$all_largest_sizes: ();
	$all_differences: ();
	
	@each $selector, $sizes in $set {
		@debug '';
		@debug '$sizes (#{meta.type_of($sizes)}):';
		@debug $sizes;
		
		@if meta.type_of($sizes) == number {
			$all_largest_sizes: map.set($all_largest_sizes, $selector, $sizes);
			$all_differences: map.set($all_differences, $selector, math.abs($sizes - $target_size));
		}
		
		@else if meta.type_of($sizes) == list {
			$all_largest_sizes: map.set($all_largest_sizes, $selector, list.nth($sizes, 1));
			$all_differences: map.set($all_differences, $selector, math.abs(list.nth($sizes, 1) - $target_size));
		}
		
		@else {
			$last_size: list.nth(map.values($sizes), list.length(map.keys($sizes)));
			@if meta.type_of($last_size) == list {
				$last_size: list.nth($last_size, 1);
			}
			
			$all_largest_sizes: map.set($all_largest_sizes, $selector, $last_size);
			$all_differences: map.set($all_differences, $selector, math.abs($last_size - $target_size));
		}
	}
	
	
	@debug '$all_largest_sizes (#{meta.type_of($all_largest_sizes)}):';
	@debug $all_largest_sizes;
	
	@debug '$all_differences (#{meta.type_of($all_differences)}):';
	@debug $all_differences;
	
	$lowest: 0;
	@each $selector, $difference in $all_differences {
		
	}
	
	@return '';
}


/// Create parabolic responsive font sizes
/// 
/// Note that this may include an unnecessary media query for the last entry
/// if it has a fixed value, but we need it there in case the second-to-last
/// value is also fixed, and therefore doesn't yield a clamp() value that
/// would obviate the need for another media query. We may also need it if
/// using the between operator, as that would also cause the value to revert
/// to the smallest breakpoint value after the last clamp().
/// 
/// Example input: (
///   h1: 56px,
///   h2: 36px 48px,
///   h3: (
///     sm: 24px,
///     lg: 32px fixed,
///     xl: 36px,
///   ),
/// )
/// 
/// @param {map} $font_sizes
@mixin parabolic_font_sizes($font_sizes, $property: 'font-size') {
	@each $selector, $sizes in $font_sizes {
		
		// Size is formatted as a single value
		// Example: (h1: 24px,)
		@if meta.type_of($sizes) == number {
			#{$selector} {
				#{$property}: $sizes;
			}
		}
		
		// Sizes are formatted in a list, using default settings for font scaling
		// breakpoints ($font_scale_breakpoint_min, $font_scale_breakpoint_max),
		// or as a map with explicity defined breakpoints
		// Examples: (
		//   h1: 24px 36px,
		//   h2: (
		//     sm: 24px,
		//     md: 32px [fixed],
		//     lg: 42px [snap 24px],
		//     xl: 36px,
		//   ),
		// ),
		@else {
			@if meta.type_of($sizes) == list {
				$sizes: _convert_font_size_list_to_map($sizes);
			}
			
			$is_integer: util.is_zero(list.nth(map.values($sizes), 1) % 1);
			$sizes: util.create_intermediate_sizes($sizes, $is_integer);
			$size_count: list.length(map.keys($sizes));
			
			$size_index: 1;
			@each $breakpoint, $size in $sizes {
				@if
					meta.type_of($size) == list
					and list.nth($size, 2) == fixed
				{
					@include b($breakpoint) {
						#{$selector} {
							#{$property}: list.nth($size, 1);
						}
					}
				}
				
				// Output a basic font size for a single defined breakpoint
				@else if $size_count == 1 {
					@include b($breakpoint) {
						#{$selector} {
							#{$property}: $size;
						}
					}
				}
				
				// For multiple input sizes, we skip the last entry, because either:
				// - its value is already accounted for in the clamp() that starts
				//   with the second-to-last entry and defines a maximum size that is
				//   equal to the size on the largest breakpoint
				// - or the size of the last entry is fixed, in which case the it has
				//   already been included by the simple check for fixed values above
				@else if $size_index < $size_count {
					$next_breakpoint: list.nth(map.keys($sizes), $size_index + 1);
					$next_size: list.nth(map.values($sizes), $size_index + 1);
					
					// If size includes any keywords, isolate first size value
					@if meta.type_of($next_size) == list {
						$next_size: list.nth($next_size, 1);
					}
					
					// If size includes snap keyword, use last size as minimum
					@if
						meta.type_of($size) == list
						and list.nth($size, 2) == snap
					{
						$size: list.nth($size, 3);
					}
					
					$fancy_set: (
						$breakpoint: $size,
						$next_breakpoint: $next_size,
					);
					
					// Use between operator to isolate font sizes to each breakpoint
					// range, rather than overriding them at every breakpoint
					$use_between_operator: true;
					
					// Use regular >= operator for second-to-last breakpoint, because
					// there is no media query after it that sets a fixed size
					$is_second_to_last_breakpoint: $size_index == $size_count - 1;
					
					// For the first size, since we're using clamp to set the minimum
					// size, which may occur at a breakpoint that's not zero, we should
					// not included a media query
					@if $size_index == 1 {
						#{$selector} {
							#{$property}: _fancy_font_size($fancy_set);
						}
					} @else {
						@if
							$use_between_operator
							and not $is_second_to_last_breakpoint
						{
							$next_smallest_breakpoint: grid.find_next_smallest_breakpoint(
								map.keys($sizes), $breakpoint
							);
							@include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
								#{$selector} {
									#{$property}: _fancy_font_size($fancy_set);
								}
							}
						} @else {
							@include b($breakpoint) {
								#{$selector} {
									#{$property}: _fancy_font_size($fancy_set);
								}
							}
						}
					}
				}
				
				$size_index: $size_index + 1;
			}
		}
	}
}
