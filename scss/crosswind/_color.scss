@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:math';

@use 'util';


$color_variable_prefix: color !default;
$colors: convert_raw_color_keys($colors);
$variants: convert_variant_keys($variants);


// Warn if color key is defined in variant that is not in the default
@each $variant_name, $variant_map in $variants {
	$default: map.get($variants, default);
	@each $color_key in map.keys($variant_map) {
		@if not map.has_key($default, $color_key) {
			@warn 'Color "#{$color_key}" in variant "#{$variant_name}" is not defined in default variant';
		}
	}
}


// Create new colors for variant values with opacity
@each $variant_name, $variant_map in $variants {
	@each $color_key, $color_name in $variant_map {
		@if meta.type_of($color_name) == list {
			$opacity: util.convert_to_number(list.nth($color_name, 2));
			$color_name: '' + list.nth($color_name, 1);
			
			@if math.unit($opacity) == '%' {
				$opacity: calc($opacity / 1%);
			}
			
			$opacity_float: $opacity;
			$opacity_int: $opacity;
			@if $opacity > 1 {
				$opacity_float: calc($opacity / 100);
			} @else {
				$opacity_int: ($opacity * 100);
			}
			
			$color_value: map.get($colors, $color_name);
			$color_name_new: '#{$color_name}-#{$opacity_int}';
			$color_value_new: transparentize(map.get($colors, $color_name), (1 - $opacity_float));
			
			// Update maps with transparentized colors
			$colors: map.set($colors, $color_name_new, $color_value_new);
			$variants: map.set($variants, $variant_name, $color_key, $color_name_new);
		}
	}
}


// Define raw colors and default variant colors
:root {
	@each $key, $value in $colors {
		#{color_var($key)}: #{$value};
	}
	@each $key, $value in map.get($variants, default) {
		#{color_var($key)}: #{color($value)};
	}
}


// Define all variant classes
@each $variant_name, $variant_map in $variants {
	.v-#{$variant_name} {
		@each $key, $value in $variant_map {
			#{color_var($key)}: #{color($value)};
		}
	}
}
