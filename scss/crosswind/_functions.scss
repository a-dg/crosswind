@use 'sass:math';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';

@import 'util';


// TODO: keep clamp values separated as long as possible, so they can be used
// individually for calculations (or figure out how to separate them)

/// Get gutter width
/// @param {string} $property: x, y, outer
/// @param {boolean} $invert
/// @param {boolean} $as_list
/// @param {map} $gutter_set
/// @return {number | calculation} *
@function gutter($property, $invert: false, $as_list: false, $gutter_set: $gutter) {
	$gutter_value: map.get($gutter_set, $property);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if $as_list {
		@if not $invert {
			@return $gutter_value;
		}
		
		@return invert_clamp_list($gutter_value);
	}
	
	@if not $invert {
		@return list_to_clamp($gutter_value);
	}
	
	$gutter_value: invert_clamp_list($gutter_value);
	@return list_to_clamp($gutter_value);
}


/// Invert and reverse list of arguments for clamp()
/// @param {list} $list
/// @return {list} *
@function invert_clamp_list($list) {
	$result: reverse_list($list);
	@return invert_list($result);
}


/// Invert all values in list
/// @param {list} $list
/// @return {list} *
@function invert_list($list) {
	$separator: list.separator($list);
	$result: ();
	@each $value in $list {
		$result: list.append($result, ($value * -1), $separator);
	}
	@return $result;
}


/// Reverse list
/// @link https://kittygiraudel.com/2013/08/08/advanced-sass-list-functions/
/// @param {list} $list
/// @param {boolean} $recursive
/// @return {list} *
@function reverse_list($list, $recursive: false) {
	$separator: list.separator($list);
	$result: ();
	
	@for $i from (list.length($list) * -1) through -1 {
		@if
			$recursive
			and meta.type_of(list.nth($list, math.abs($i))) == list
		{
			$result: list.append(
				$result,
				reverse_list(list.nth($list, math.abs($i)), $recursive),
				$separator
			);
		} @else {
			$result: list.append($result, list.nth($list, math.abs($i)), $separator);
		}
	}
	
	@return $result;
}


/// Convert three-element list to clamp(), or return first element
/// @param {list} $list
/// @return {calculation} *
@function list_to_clamp($list) {
	@if meta.type_of($list) != list {
		@return $list;
	}
	
	@if list.length($list) != 3 {
		@error 'List passed to list_to_clamp() was not three elements: ' + $list;
		@return list.nth($list, 1);
	}
	
	@return clamp(
		list.nth($list, 1),
		list.nth($list, 2),
		list.nth($list, 3)
	);
}


/// Get max gutter width
/// @param {string} $axis
/// @param {boolean} $invert
/// @return {number | string} *
@function gutter_max($axis, $invert: false) {
	$gutter_value: map.get($gutter, $axis);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return list.nth($gutter_value, 3);
	}
	
	@return (list.nth($gutter_value, 3) * -1);
}


/// Get gutter value for extending beyond max width, either to edge of
/// viewport or stopping at $content_max_width_extended
/// 
/// Alternate expressions:
/// - calc(((100vw - ($content_max_width - (gutter_max(x) * 2))) / -2));
/// - calc(((100vw - $content_max_width) / -2) - gutter_max(x));
/// 
/// @param {boolean} $to_viewport_edge
/// @param {boolean} $invert
/// @param {number} $offset
/// @return {string} *
@function gutter_extended($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	
	// TODO: is gutter_max() ever what we want? We have clamp
	// Well, as long as gutter_extended() takes effect once we reach
	// $content_max_width, then it's ok
	$something_special: calc(
		(50vw * $inversion)
		- (
			(($content_max_width / 2) - gutter_max(outer) + $offset)
			* $inversion
		)
	);
	
	@if $to_viewport_edge {
		@return $something_special;
	}
	
	// Difference between $content_max_width and $content_max_width_extended,
	// noting that $content_max_width includes the space taken up by the outer
	// gutter, while $content_max_width_extended does not
	$content_extension: calc(((($content_max_width_extended - $content_max_width) / 2) + gutter_max(outer)) * $inversion);
	
	// TODO: check this with all gutter types
	$stuff: (
		$content_extension,
		$something_special,
		(gutter_max(outer) * $inversion)
	);
	@if not $invert {
		$stuff: reverse_list($stuff);
	}
	
	@return list_to_clamp($stuff);
}


@function gutter_extended2($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	
	$something_special: calc(
		(50vw * $inversion)
		- (
			(($content_max_width / 2) - gutter_max(outer) + $offset)
			* $inversion
		)
	);
	
	@if $to_viewport_edge {
		@return $something_special;
	}
	
	// TODO: check this with all gutter types
	@return clamp(
		calc(($content_max_width_extended - $content_max_width) / -2),
		$something_special,
		(gutter_max(outer) * -1)
	);
}


/// Calculate width of element within grid system
/// 
/// Usage:
/// margin-right: grid_element_width(
///   1, 3, $gutter_base_x, $include_external_gutter: true
/// );
/// 
/// @param {int} $column_span: Number of columns to shift
/// @param {int} $total_columns: Number of columns already occupied by element
/// @param {number} $gutter_width
/// @param {boolean} $is_negative
/// @param {boolean} $include_external_gutter: Sometimes it's necessary to
///   include one more gutter in addition to the ones in between the columns
/// @return {number} *
@function grid_element_width(
	$column_span,
	$total_columns,
	$gutter_width: gutter(x, $as_list: true),
	$is_negative: false,
	$include_external_gutter: false
) {
	
	// TODO: none of this math works when CSS variables are used
	
	// TODO: values are truncated too early
	
	// Example gutter width:
	// $gutter_width: 16px, 4.16vw, 48px
	
	// Width of all gutters combined (fixed: px; flexible: clamp(px, vw, px))
	// $total_gutter_width: calc(($total_columns - 1) * $gutter_width);
	$total_gutter_width: operate_list($gutter_width, $multiply: ($total_columns - 1));
	// 176px, 45.76vw, 528px
	
	// Share of width occupied by spanned columns (float)
	$multiplier: calc($column_span / $total_columns);
	// 0.666666
	
	// Width remaining for spanned columns after gutters have been removed (% + px)
	$remaining_column_space: truncate(100% * $multiplier);
	// 66.6666%
	
	$remaining_gutter_space: truncate(operate_list($total_gutter_width, $multiply: $multiplier));
	// 117.3333px, 30.5066vw, 352px
	
	// Width of gutters between spanned columns, plus optionally one more
	// (fixed: px; flexible: clamp(px, vw, px))
	$spanned_gutter_space: operate_list(
		$gutter_width,
		$multiply: ($column_span - if($include_external_gutter, 0, 1))
	);
	// 112px, 29.12vw, 336px
	
	$leftover_gutter_space: subtract_lists($remaining_gutter_space, $spanned_gutter_space);
	
	// When numbers go negative, we have to reverse the clamp() list to put min
	// and max values in the right order
	@if
		list.nth($leftover_gutter_space, 1) < 0
		and list.nth($leftover_gutter_space, 2) < 0
	{
		$leftover_gutter_space: reverse_list($leftover_gutter_space);
	}
	
	$gutter_remainder: list_to_clamp($leftover_gutter_space);
	
	@if $is_negative {
		// TODO: don't know if this works yet
		@return calc(($remaining_column_space * -1) - $gutter_remainder);
	}
	
	@return calc($remaining_column_space - $gutter_remainder);
}


// TODO: make this work with $offset_columns and $element_columns as map
// TODO: compare this with grid_float, because the same logic could be used
/// Calculate offset of element within grid system
/// @param {int} $offset_columns: Number of columns to shift
/// @param {int} $element_columns: Element width in columns
/// @param {number} $gutter_width
/// @return {calculation} *
@function grid_element_offset(
	$offset_columns,
	$element_columns,
	$gutter_width: gutter(x, $as_list: true)
) {
	$multiplier: calc($offset_columns / $element_columns);
	$offset_percent: truncate(100% * $multiplier);
	$offset_gutter: operate_list($gutter_width, $multiply: $multiplier);
	
	@if $offset_columns < 0 {
		$offset_gutter: invert_list($offset_gutter);
		@return calc($offset_percent - list_to_clamp($offset_gutter));
	}
	
	@return calc($offset_percent + list_to_clamp($offset_gutter));
}


/// Add elements from two lists
/// @param {list} $a
/// @param {list} $b
/// @return {list} *
@function add_lists($a, $b) {
	@return combine_lists($a, $b, '+');
}


/// Subtract elements from two lists
/// @param {list} $a
/// @param {list} $b
/// @return {list} *
@function subtract_lists($a, $b) {
	@return combine_lists($a, $b, '-');
}


/// Perform calculation on two lists
/// @param {list} $a
/// @param {list} $b
/// @param {string} $operator
/// @return {list} *
@function combine_lists($a, $b, $operator) {
	@if
		meta.type_of($a) != list
		and meta.type_of($b) != list
	{
		@return operate($a, $b, $operator);
	}
	
	@if list.length($a) != list.length($b) {
		@error 'Lists passed to combine_lists() must be of same length';
	}
	
	$separator: list.separator($a);
	$result: ();
	$index: 1;
	@each $a_item in $a {
		$b_item: list.nth($b, $index);
		$item_result: operate($a_item, $b_item, $operator);
		$result: list.append($result, $item_result, $separator);
		$index: $index + 1;
	}
	@return $result;
}


/// Perform calculation on two values
/// @param {number} $a
/// @param {number} $b
/// @param {string} $operator
/// @return {number} *
@function operate($a, $b, $operator) {
	$result: 0;
	@if $operator == '+' {
		$result: ($a + $b);
	} @else if $operator == '-' {
		$result: ($a - $b);
	} @else if $operator == '*' {
		$result: ($a * $b);
	} @else if $operator == '/' {
		$result: calc($a / $b);
	}
	@return $result;
}


/// Peform calculation on each element in list
/// @param {list | number} $input
/// @param {number} $multiply
/// @param {number} $add
/// @return {list | number} *
@function operate_list($input, $multiply: 1, $add: 0) {
	@if meta.type_of($input) != list {
		$list_item_result: $input;
		@return operate_value($input, $multiply, $add);
	}
	
	$separator: list.separator($input);
	$result: ();
	@each $value in $input {
		$unit: math.unit($value);
		$list_item_result: operate_value($value, $multiply, $add);
		$result: list.append(
			$result,
			$list_item_result,
			$separator
		);
	}
	@return $result;
}


/// Peform calculation on value
/// @param {number} $input
/// @param {number} $multiply
/// @param {number} $add
/// @return {number} *
@function operate_value($input, $multiply: 1, $add: 0) {
	$result: $input;
	@if $multiply != 1 {
		$result: ($result * $multiply);
	}
	@if not is_zero($add) {
		$result: calc($result + $add);
	}
	@return $result;
}


/// Round number to nearest multiple
/// @param {number} $value
/// @return {int} *
@function round_to($value, $multiple) {
	@return (math.round(calc($value / $multiple)) * $multiple);
}


/// Round number to nearest multiple of 2
/// @param {number} $value
/// @return {int} *
@function round_even($value) {
	@return round_to($value, 2);
}


/// Round number to nearest multiple of 4
/// @param {number} $value
/// @return {int} *
@function round_four($value) {
	@return round_to($value, 4);
}


/// Round number to nearest multiple of 16
/// @param {number} $value
/// @return {int} *
@function round_sixteen($value) {
	@return round_to($value, 16);
}


/// Is this value a percentage?
/// @param {number} $value
/// @return {boolean} *
@function is_percent($value) {
	@return math.unit($value) == '%';
}


/// Truncate decimal to specified number of places
/// @param {number | list} $value
/// @param {int} $places
/// @return {number} *
@function truncate($value, $places: 4) {
	@return $value;
	
	// TODO: verify that flooring does not cause elements to accidentally reflow
	// when using negative numbers
	
	@if meta.type_of($value) == list {
		$separator: list.separator($value);
		$result: ();
		@each $list_item in $value {
			$result: list.append($result, truncate($list_item), $separator);
		}
		@return $result;
	}
	
	@return calc(math.floor($value * math.pow(10, $places)) / math.pow(10, $places));
}


/// Truncate decimal to specified number of places
/// @param {number | list} $value
/// @param {int} $places
/// @return {number} *
@function trunx($value, $places: 4) {
	// TODO: verify that flooring does not cause elements to accidentally reflow
	// when using negative numbers
	
	@if meta.type_of($value) == list {
		$separator: list.separator($value);
		$result: ();
		@each $list_item in $value {
			$result: list.append($result, truncate($list_item), $separator);
		}
		@return $result;
	}
	
	@return calc(math.floor($value * math.pow(10, $places)) / math.pow(10, $places));
}


/// Replace in string
/// @param {string} $input
/// @param {string} $search
/// @param {string} $replace
/// @return {string} *
@function replace($input, $search, $replace: '') {
	$index: string.index($input, $search);
	@if not $index {
		@return $input;
	}
	
	@return string.slice($input, 1, $index - 1) + $replace + replace(
		string.slice($input, $index + string.length($search)), $search, $replace
	);
}


/// Find next smallest breakpoint for range
/// 
/// Start with a breakpoint in a subset of breakpoints, find the next
/// breakpoint in the subset, then find next smallest breakpoint in all
/// breakpoints. This is useful for creating a media query where you don't
/// want to define unique (and perhaps redundant) parameters for every
/// single breakpoint.
/// 
/// For example, if complex grid styles are too tedious to override
/// using ">=" media queries, it's better to use "=" media queries. However,
/// all parameters for the grid must be explicitly defined for every
/// breakpoint, even if they don't change at every breakpoint, because they
/// won't be inherited from smaller breakpoints. With this function, it's
/// possible to define only non-redundant parameters, and create range
/// breakpoints (using the "><" operator). This simplifies configuration and
/// reduces the number of media queries required.
/// 
/// Example:
/// - All breakpoints: sm, md, lg, xl, xxl
/// - Subset: sm, xl, xxl
/// - Next smallest breakpoint for "sm" in subset: lg (one down from xl)
/// 
/// @param {list} $breakpoint_subset_keys
/// @param {string} $breakpoint
/// @return {string} *
@function find_next_smallest_breakpoint($breakpoint_subset_keys, $breakpoint) {
	$all_breakpoint_keys: map.keys($breakpoints);
	
	$current_subset_index: list.index($breakpoint_subset_keys, $breakpoint);
	$next_subset_index: math.min(($current_subset_index + 1), list.length($breakpoint_subset_keys));
	$next_subset_breakpoint: list.nth($breakpoint_subset_keys, $next_subset_index);
	@if $next_subset_breakpoint == $breakpoint {
		@return list.nth($all_breakpoint_keys, list.length($all_breakpoint_keys));
	}
	
	$next_all_index: list.index($all_breakpoint_keys, $next_subset_breakpoint);
	$next_smallest_index: math.max(1, $next_all_index - 1);
	$next_smallest_breakpoint: list.nth($all_breakpoint_keys, $next_smallest_index);
	@return $next_smallest_breakpoint;
}


/// Find largest smaller breakpoint in subset
/// 
/// Sort of the opposite of find_next_smallest_breakpoint(): given any
/// breakpoint, find the largest explicitly defined breakpoint that is not
/// larger than the given breakpoint. This can return the given breakpoint
/// itself, since it is explicitly defined, and is not larger than itself.
/// 
/// Example:
/// - All breakpoints: sm, md, lg, xl, xxl
/// - Subset: sm, xl, xxl
/// - Largest smaller breakpoint for "lg" in subset: sm
/// - Largest smaller breakpoint for "xl" in subset: xl
/// 
/// @param {list} $breakpoint_subset_keys
/// @param {string} $breakpoint
/// @return {string} *
@function find_largest_smaller_breakpoint($breakpoint_subset_keys, $breakpoint) {
	$all_breakpoint_keys: map.keys($breakpoints);
	
	@if list.index($breakpoint_subset_keys, $breakpoint) != null {
		@return $breakpoint;
	}
	
	// If we go over this, stop caring
	$breakpoint_index: list.index($all_breakpoint_keys, $breakpoint);
	
	$largest_subset_index: 1;
	@for $i from 1 through list.length($all_breakpoint_keys) {
		@if $i < $breakpoint_index {
			$current_breakpoint: list.nth($all_breakpoint_keys, $i);
			@if list.index($breakpoint_subset_keys, $current_breakpoint) != null {
				$largest_subset_index: list.index($breakpoint_subset_keys, $current_breakpoint);
			}
		}
	}
	
	@return list.nth($breakpoint_subset_keys, $largest_subset_index);
}


/// Split list at first occurrence of delimiter
/// @param {list} $input
/// @param {string} $delimiter
/// @return {map} List parts as a, b
@function split_list($input, $delimiter) {
	@if
		type_of($input) != list
		or not list.index($input, $delimiter)
	{
		@return (
			a: $input,
			b: null,
		);
	}
	
	$list_a: ();
	$list_b: ();
	$is_before_split: true;
	
	@each $item in $input {
		@if $item == $delimiter {
			$is_before_split: false;
		} @else {
			@if $is_before_split {
				$list_a: list.append($list_a, $item, $separator: space);
			} @else {
				$list_b: list.append($list_b, $item, $separator: space);
			}
		}
	}
	
	// TODO: consider this method of splitting lists
	// $list: 3 4 r 1 o -2;
	// $string: meta.inspect($list);
	// $split_list: string.split($string, o);
	// @debug $split_list;
	// @debug meta.type_of($split_list);
	
	@return (
		a: $list_a,
		b: $list_b,
	);
}


/// Fancy font size
/// 
/// Usage for linear scaling:
/// font-size: fancy_font_size((
///   sm: 24px,
///   xl: 72px,
/// ));
/// 
/// For non-linear scaling, use parabolic_font_sizes()
/// 
/// @param {map} param
/// @return {number | calculation} Fixed size or clamp()
@function fancy_font_size($set) {
	$min: list.nth(map.values($set), 1);
	@if list.length(map.values($set)) == 1 {
		@return $min;
	}
	
	$max: list.nth(map.values($set), 2);
	$start: map.get($breakpoints, list.nth(map.keys($set), 1));
	$end: map.get($breakpoints, list.nth(map.keys($set), 2));
	
	$size_fixed: calc(($max - $min) / ($end - $start));
	@if $size_fixed == 0 {
		@return $min;
	}
	
	$size_fluid: ($size_fixed * 100vw);
	$size_preferred: calc(trunx($size_fluid) + trunx($min - ($size_fixed * $start)));
	
	@if $min > $max {
		$min_swap: $min;
		$min: $max;
		$max: $min_swap;
	}
	
	@return clamp($min, $size_preferred, $max);
}


/// Interpolate numbers on a curve
/// 
/// Control acceleration of intervals with $curve:
/// - 0: No curvature, evenly-spaced numbers
/// - 0.5: Some curvature, smaller intervals at start of range
/// - 1: Greater curvature, more drastic change in intervals
/// - -0.5: Opposite curvature, larger intervals at start of range
/// 
/// @param {int} $start: starting number
/// @param {int} $end: ending number
/// @param {int} $count: total number of numbers
/// @param {float} $curve: acceleration of intervals
/// @param {bool} $round: round values
/// @return {list} *
@function interpolate($start, $end, $count, $curve: 1, $round: false) {
	$step: calc(($end - $start) / ($count - 1));
	$is_negative_curve: $curve < 0;
	$inversion: if($is_negative_curve, -1, 1);
	@if $is_negative_curve {
		$curve: ($curve * -1);
		$start_swap: $start;
		$start: $end;
		$end: $start_swap;
	}
	
	$values: ();
	@for $i from 0 through ($count - 1) {
		$x: calc($i / ($count - 1));
		$y: calc(math.pow($curve, $x) / $curve);
		$value: ($start + ($i * $step * $y * $inversion));
		@if $round {
			$value: math.round($value);
		}
		$values: append($values, $value);
	}
	
	@if $is_negative_curve {
		$values: reverse_list($values);
	}
	
	@return $values;
}


/// Convert two-item list to map, using default font scaling breakpoints
/// @param {list} $sizes
/// @return {map} *
@function convert_font_size_list_to_map($sizes) {
	@return (
		$font_scale_breakpoint_min: list.nth($sizes, 1),
		$font_scale_breakpoint_max: list.nth($sizes, 2),
	);
}


/// Create breakpoints
/// @param {list} $names
/// @param {int} $start: Smallest non-zero breakpoint
/// @param {int} $end: Largest breakpoint
/// @param {float} $curve
/// @param {map} $additional
/// @param {int} $round_to
/// @return {map} *
@function create_breakpoints($names, $start, $end, $curve, $additional, $round_to: 4) {
	@if $start < $content_min_width {
		@warn 'A value of ' + $start + ' for the first non-zero breakpoint might be a bit small. The minimum content width is ' + $content_min_width + ', which means that users would never see the first breakpoint.';
	}
	
	$start: strip_units($start);
	$end: strip_units($end);
	
	@if $start % $round_to > 0 {
		@warn 'The value of ' + $start + ' for the first non-zero breakpoint is not a multiple of ' + $round_to + ', so its interpolated breakpoint value will be different.';
	}
	@if $end % $round_to > 0 {
		@warn 'The value of ' + $end + ' for the last breakpoint is not a multiple of ' + $round_to + ', so its interpolated breakpoint value will be different.';
	}
	
	$values: list.join((0,), interpolate(
		$start: math.round(calc($start / $round_to)),
		$end: math.round(calc($end / $round_to)),
		$count: list.length($names) - 1,
		$curve: $curve,
		$round: true
	));
	
	$generated: ();
	@for $i from 1 through list.length($names) {
		$name: list.nth($names, $i);
		$value: (list.nth($values, $i) * $round_to * 1px);
		$generated: map.set($generated, $name, $value);
	}
	
	@if list.length(map.values($additional)) == 0 {
		@return $generated;
	}
	
	// Remove entries from generated breakpoints if they match either the name or
	// size of an additional breakpoint defined explicitly
	$remove_additional_keys: ();
	@each $key, $value in $additional {
		$additional_key_index: list.index(map.keys($generated), $key);
		$additional_value_index: list.index(map.values($generated), $value);
		
		@if $additional_key_index != null {
			$value_generated: map.get($generated, $key);
			@warn 'The breakpoint named "#{$key}" in $breakpoint_additional (#{$value}) already exists as a generated breakpoint. The generated "#{$key}" breakpoint (#{$value_generated}) has been removed.';
			$remove_additional_keys: list.append($remove_additional_keys, $key);
		}
		
		@else if $additional_value_index != null {
			$key_generated: list.nth(map.keys($generated), $additional_value_index);
			@warn 'The value for "#{$key}" in $breakpoint_additional (#{$value}) is the same as the generated breakpoint value for "#{$key_generated}". The generated "#{$key}" breakpoint has been removed.';
			$remove_additional_keys: list.append($remove_additional_keys, $key_generated);
		}
	}
	
	@debug '$remove_additional_keys (' + meta.type_of($remove_additional_keys) + '):';
	@debug $remove_additional_keys;
	
	@each $key in $remove_additional_keys {
		$generated: map.remove($generated, $key);
	}
	
	$generated: map_insert($generated, $additional);
	@return $generated;
}


/// Create interpolated sizes for intermediate breakpoints
/// 
/// Output is a map defining explicit sizes for every breakpoint between
/// start and end breakpoints. Used in conjunction with mixins for creating
/// parabolic responsive values, like parabolic_font_sizes().
/// 
/// Note: this process has the potential to create some redundant key/value
/// pairs. However, since map entries are assigned by specifying the key and
/// value, any redundant key simply overwrites the existing pair, so it makes
/// no difference in the end.
/// 
/// Input: (
///   sm: 24px,
///   xl: 36px,
/// )
/// Output: (
///   sm: 24px,
///   md: 28px, <- Creates interpolates sizes
///   lg: 32px, <- for intermediate breakpoints
///   xl: 36px,
/// )
/// 
/// Use the "fixed" keyword to hold a fixed font size until the next defined
/// breakpoint. (Alternatively, define consecutive breakpoints having the
/// same value.)
/// 
/// Input with "fixed": (
///   sm: 24px,
///   md: 28px fixed,
///   xl: 36px,
/// )
/// Output with "fixed": (
///   sm: 24px,
///   md: 28px fixed,
///   (No "lg" size generated)
///   xl: 36px,
/// )
/// 
/// @param {map} $sizes
/// @return {map} *
@function create_intermediate_sizes($sizes, $with_rounding: true) {
	@if list.length(map.keys($sizes)) == 1 {
		@return $sizes;
	}
	
	$complete_sizes: ();
	
	$size_index: 1;
	@each $breakpoint, $size in $sizes {
		$has_keyword: meta.type_of($size) == list;
		
		// If this size has a keyword (such as "fixed"), do not interpolate between
		// this and the next in the set
		@if $has_keyword {
			$complete_sizes: map.set(
				$complete_sizes,
				$breakpoint,
				$size
			);
			
			$is_first_breakpoint: list.index(map.keys($breakpoints), $breakpoint) == 1;
			@if
				$size_index == 1
				and not $is_first_breakpoint
			{
				@warn 'The first font size (' + $breakpoint + ': ' + $size + ') is defined as fixed, so there will be no font size for breakpoints below ' + $breakpoint;
			}
		}
		
		@else {
			@if $size_index < list.length(map.keys($sizes)) {
				$this_index_in_all: list.index(map.keys($breakpoints), $breakpoint);
				
				$next_breakpoint: list.nth(map.keys($sizes), $size_index + 1);
				$next_size: list.nth(map.values($sizes), $size_index + 1);
				$next_size_keyword: null;
				@if meta.type_of($next_size) == list {
					$next_size_keyword: list.nth($next_size, 2);
					$next_size: list.nth($next_size, 1);
				}
				$next_index_in_all: list.index(map.keys($breakpoints), $next_breakpoint);
				
				$intermediate_size_count: ($next_index_in_all - $this_index_in_all) - 1;
				@if $intermediate_size_count > 0 {
					$intermediate_sizes: interpolate(
						$start: $size,
						$end: $next_size,
						$count: $intermediate_size_count + 2,
						$curve: $font_scale_curve,
						$round: $with_rounding
					);
					
					// Pair each intermediate size with a breakpoint
					$intermediate_index: 1;
					@each $intermediate_size in $intermediate_sizes {
						// If there is a keyword on the next size, and we're on the last
						// intermediate size, that means we're on the one with the keyword,
						// and we need to add the keyword back so that it's represented in
						// the complete list
						@if
							$next_size_keyword != null
							and $intermediate_index == list.length($intermediate_sizes)
						{
							$intermediate_size: ($intermediate_size $next_size_keyword);
						}
						
						$intermediate_breakpoint_index: ($this_index_in_all + $intermediate_index) - 1;
						$complete_sizes: map.set(
							$complete_sizes,
							list.nth(map.keys($breakpoints), $intermediate_breakpoint_index),
							$intermediate_size
						);
						$intermediate_index: $intermediate_index + 1;
					}
					
				} @else {
					$complete_sizes: map.set($complete_sizes, $breakpoint, $size);
				}
			}
			
			// If this is the last entry, add it manually
			@else {
				$complete_sizes: map.set(
					$complete_sizes,
					$breakpoint,
					$size
				);
			}
		}
		
		$size_index: $size_index + 1;
	}
	
	@return $complete_sizes;
}


/// Find closest font size to target
/// @param {map} $set
/// @param {number} $target_size
/// @return {map} *
@function closest_font_size($set, $target_size) {
	
	$all_largest_sizes: ();
	$all_differences: ();
	
	@each $selector, $sizes in $set {
		@debug '';
		@debug '$sizes (' + meta.type_of($sizes) + '):';
		@debug $sizes;
		
		@if meta.type_of($sizes) == number {
			$all_largest_sizes: map.set($all_largest_sizes, $selector, $sizes);
			$all_differences: map.set($all_differences, $selector, math.abs($sizes - $target_size));
		}
		
		@else if meta.type_of($sizes) == list {
			$all_largest_sizes: map.set($all_largest_sizes, $selector, list.nth($sizes, 1));
			$all_differences: map.set($all_differences, $selector, math.abs(list.nth($sizes, 1) - $target_size));
		}
		
		@else {
			$last_size: list.nth(map.values($sizes), list.length(map.keys($sizes)));
			@if meta.type_of($last_size) == list {
				$last_size: list.nth($last_size, 1);
			}
			
			$all_largest_sizes: map.set($all_largest_sizes, $selector, $last_size);
			$all_differences: map.set($all_differences, $selector, math.abs($last_size - $target_size));
		}
	}
	
	
	@debug '$all_largest_sizes (' + meta.type_of($all_largest_sizes) + '):';
	@debug $all_largest_sizes;
	
	@debug '$all_differences (' + meta.type_of($all_differences) + '):';
	@debug $all_differences;
	
	$lowest: 0;
	@each $selector, $difference in $all_differences {
		
	}
	
	@return '';
}
