@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:meta';

@use '../app/config';
@use 'util';

// @use 'function' as *;
@use '../lib/breakbeat' as *;


$content_width_prop: --content-width;

$content_max_width: null;
$content_max_width_extended: null;


$breakpoint_names: () !default;
$breakpoint_width_min: 0 !default;
$breakpoint_width_max: 0 !default;
$breakpoint_scale_curve: 1 !default;
$breakpoint_additions: () !default;

// $breakpoints: create_breakpoints(
// 	config.$breakpoint_names,
// 	config.$breakpoint_width_min,
// 	config.$breakpoint_width_max,
// 	config.$breakpoint_scale_curve,
// 	config.$breakpoint_additions
// );




// TODO: what is the advantage of using CSS variables?
// "Custom properties make sense when we have CSS properties that change
// relative to a condition in the DOM, especially a dynamic condition such as
// :focus, :hover, media queries or with JavaScript."
// - https://www.smashingmagazine.com/2018/05/css-custom-properties-strategy-guide/
$gutter_fixed: (
	x: config.$gutter_base_x,
	y: config.$gutter_base_y,
	outer: config.$gutter_base_outer,
	// x: var(--gutter-x),
	// y: var(--gutter-y),
	// outer: var(--gutter-outer),
);

$gutter_stepped: (
	x: var(--gutter-stepped-x),
	y: var(--gutter-stepped-y),
	outer: var(--gutter-stepped-outer),
);

$gutter_flexible: ();

$gutter_type: flexible !default;
$gutter: ();

// @debug '$gutter_type (#{meta.type_of($gutter_type)}):';
// @debug $gutter_type;

// @debug '$gutter (#{meta.type_of($gutter)}):';
// @debug $gutter;




// TODO: keep clamp values separated as long as possible, so they can be used
// individually for calculations (or figure out how to separate them)

/// Get gutter width
/// @param {string} $property: x, y, outer
/// @param {boolean} $invert
/// @param {boolean} $as_list
/// @param {map} $gutter_set
/// @param {string} $caller
/// @return {number | calculation} *
@function gutter($property, $invert: false, $as_list: false, $gutter_set: $gutter, $caller: '') {
	// @debug 'gutter() called from: #{$caller}';
	$gutter_value: map.get($gutter_set, $property);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if $as_list {
		@if not $invert {
			@return $gutter_value;
		}
		
		@return util.invert_clamp_list($gutter_value);
	}
	
	@if not $invert {
		@return util.list_to_clamp($gutter_value);
	}
	
	$gutter_value: util.invert_clamp_list($gutter_value);
	@return util.list_to_clamp($gutter_value);
}


/// Get max gutter width
/// @param {string} $axis
/// @param {boolean} $invert
/// @return {number | string} *
@function gutter_max($axis, $invert: false) {
	$gutter_value: map.get($gutter, $axis);
	@if meta.type_of($gutter_value) != list {
		@return if($invert, calc($gutter_value * -1), $gutter_value);
	}
	
	@if not $invert {
		@return list.nth($gutter_value, 3);
	}
	
	@return (list.nth($gutter_value, 3) * -1);
}


/// Get gutter value for extending beyond max width, either to edge of
/// viewport or stopping at $content_max_width_extended
/// 
/// Alternate expressions:
/// - calc(((100vw - ($content_max_width - (gutter_max(x) * 2))) / -2));
/// - calc(((100vw - $content_max_width) / -2) - gutter_max(x));
/// 
/// @param {boolean} $to_viewport_edge
/// @param {boolean} $invert
/// @param {number} $offset
/// @return {string} *
@function gutter_extended($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	
	// TODO: is gutter_max() ever what we want? We have clamp
	// Well, as long as gutter_extended() takes effect once we reach
	// $content_max_width, then it's ok
	$something_special: calc(
		(50vw * $inversion)
		- (
			(($content_max_width / 2) - gutter_max(outer) + $offset)
			* $inversion
		)
	);
	
	@if $to_viewport_edge {
		@return $something_special;
	}
	
	// Difference between $content_max_width and $content_max_width_extended,
	// noting that $content_max_width includes the space taken up by the outer
	// gutter, while $content_max_width_extended does not
	$content_extension: calc(((($content_max_width_extended - $content_max_width) / 2) + gutter_max(outer)) * $inversion);
	
	// TODO: check this with all gutter types
	$stuff: (
		$content_extension,
		$something_special,
		(gutter_max(outer) * $inversion)
	);
	@if not $invert {
		$stuff: util.reverse_list($stuff);
	}
	
	@return util.list_to_clamp($stuff);
}


@function gutter_extended2($to_viewport_edge: true, $invert: true, $offset: 0px) {
	$inversion: if($invert, -1, 1);
	
	$something_special: calc(
		(50vw * $inversion)
		- (
			(($content_max_width / 2) - gutter_max(outer) + $offset)
			* $inversion
		)
	);
	
	@if $to_viewport_edge {
		@return $something_special;
	}
	
	// TODO: check this with all gutter types
	@return clamp(
		calc(($content_max_width_extended - $content_max_width) / -2),
		$something_special,
		(gutter_max(outer) * -1)
	);
}


/// Calculate width of element within grid system
/// 
/// Usage:
/// margin-right: grid_element_width(
///   1, 3, $gutter_base_x, $include_external_gutter: true
/// );
/// 
/// @param {int} $column_span: Number of columns to shift
/// @param {int} $total_columns: Number of columns already occupied by element
/// @param {number} $gutter_width
/// @param {boolean} $is_negative
/// @param {boolean} $include_external_gutter: Sometimes it's necessary to
///   include one more gutter in addition to the ones in between the columns
/// @return {number} *
@function grid_element_width(
	$column_span,
	$total_columns,
	$gutter_width: gutter(x, $as_list: true),
	$is_negative: false,
	$include_external_gutter: false
) {
	
	// TODO: not sure I like gutter() in the args
	
	// TODO: none of this math works when CSS variables are used
	
	// TODO: values are truncated too early
	
	// Example gutter width:
	// $gutter_width: 16px, 4.16vw, 48px
	
	// Width of all gutters combined (fixed: px; flexible: clamp(px, vw, px))
	// $total_gutter_width: calc(($total_columns - 1) * $gutter_width);
	$total_gutter_width: util.operate_list($gutter_width, $multiply: ($total_columns - 1));
	// 176px, 45.76vw, 528px
	
	// Share of width occupied by spanned columns (float)
	$multiplier: calc($column_span / $total_columns);
	// 0.666666
	
	// Width remaining for spanned columns after gutters have been removed (% + px)
	$remaining_column_space: util.truncate(100% * $multiplier);
	// 66.6666%
	
	$remaining_gutter_space: util.truncate(util.operate_list($total_gutter_width, $multiply: $multiplier));
	// 117.3333px, 30.5066vw, 352px
	
	// Width of gutters between spanned columns, plus optionally one more
	// (fixed: px; flexible: clamp(px, vw, px))
	$spanned_gutter_space: util.operate_list(
		$gutter_width,
		$multiply: ($column_span - if($include_external_gutter, 0, 1))
	);
	// 112px, 29.12vw, 336px
	
	$leftover_gutter_space: util.subtract_lists($remaining_gutter_space, $spanned_gutter_space);
	
	// When numbers go negative, we have to reverse the clamp() list to put min
	// and max values in the right order
	@if
		list.nth($leftover_gutter_space, 1) < 0
		and list.nth($leftover_gutter_space, 2) < 0
	{
		$leftover_gutter_space: util.reverse_list($leftover_gutter_space);
	}
	
	$gutter_remainder: util.list_to_clamp($leftover_gutter_space);
	
	@if $is_negative {
		// TODO: don't know if this works yet
		@return calc(($remaining_column_space * -1) - $gutter_remainder);
	}
	
	@return calc($remaining_column_space - $gutter_remainder);
}


// TODO: make this work with $offset_columns and $element_columns as map
// TODO: compare this with grid_float, because the same logic could be used
/// Calculate offset of element within grid system
/// @param {int} $offset_columns: Number of columns to shift
/// @param {int} $element_columns: Element width in columns
/// @param {number} $gutter_width
/// @return {calculation} *
@function grid_element_offset(
	$offset_columns,
	$element_columns,
	$gutter_width: gutter(x, $as_list: true)
) {
	$multiplier: calc($offset_columns / $element_columns);
	$offset_percent: util.truncate(100% * $multiplier);
	$offset_gutter: util.operate_list($gutter_width, $multiply: $multiplier);
	
	@if $offset_columns < 0 {
		$offset_gutter: util.invert_list($offset_gutter);
		@return calc($offset_percent - util.list_to_clamp($offset_gutter));
	}
	
	@return calc($offset_percent + util.list_to_clamp($offset_gutter));
}


/// Add elements from two lists
/// Find next smallest breakpoint for range
/// 
/// Start with a breakpoint in a subset of breakpoints, find the next
/// breakpoint in the subset, then find next smallest breakpoint in all
/// breakpoints. This is useful for creating a media query where you don't
/// want to define unique (and perhaps redundant) parameters for every
/// single breakpoint.
/// 
/// For example, if complex grid styles are too tedious to override
/// using ">=" media queries, it's better to use "=" media queries. However,
/// all parameters for the grid must be explicitly defined for every
/// breakpoint, even if they don't change at every breakpoint, because they
/// won't be inherited from smaller breakpoints. With this function, it's
/// possible to define only non-redundant parameters, and create range
/// breakpoints (using the "><" operator). This simplifies configuration and
/// reduces the number of media queries required.
/// 
/// Example:
/// - All breakpoints: sm, md, lg, xl, xxl
/// - Subset: sm, xl, xxl
/// - Next smallest breakpoint for "sm" in subset: lg (one down from xl)
/// 
/// @param {list} $breakpoint_subset_keys
/// @param {string} $breakpoint
/// @return {string} *
@function find_next_smallest_breakpoint($breakpoint_subset_keys, $breakpoint) {
	$all_breakpoint_keys: map.keys($breakpoints);
	
	$current_subset_index: list.index($breakpoint_subset_keys, $breakpoint);
	$next_subset_index: math.min(($current_subset_index + 1), list.length($breakpoint_subset_keys));
	$next_subset_breakpoint: list.nth($breakpoint_subset_keys, $next_subset_index);
	@if $next_subset_breakpoint == $breakpoint {
		@return list.nth($all_breakpoint_keys, list.length($all_breakpoint_keys));
	}
	
	$next_all_index: list.index($all_breakpoint_keys, $next_subset_breakpoint);
	$next_smallest_index: math.max(1, $next_all_index - 1);
	$next_smallest_breakpoint: list.nth($all_breakpoint_keys, $next_smallest_index);
	@return $next_smallest_breakpoint;
}


/// Find largest smaller breakpoint in subset
/// 
/// Sort of the opposite of find_next_smallest_breakpoint(): given any
/// breakpoint, find the largest explicitly defined breakpoint that is not
/// larger than the given breakpoint. This can return the given breakpoint
/// itself, since it is explicitly defined, and is not larger than itself.
/// 
/// Example:
/// - All breakpoints: sm, md, lg, xl, xxl
/// - Subset: sm, xl, xxl
/// - Largest smaller breakpoint for "lg" in subset: sm
/// - Largest smaller breakpoint for "xl" in subset: xl
/// 
/// @param {list} $breakpoint_subset_keys
/// @param {string} $breakpoint
/// @return {string} *
@function find_largest_smaller_breakpoint($breakpoint_subset_keys, $breakpoint) {
	$all_breakpoint_keys: map.keys($breakpoints);
	
	@if list.index($breakpoint_subset_keys, $breakpoint) != null {
		@return $breakpoint;
	}
	
	// If we go over this, stop caring
	$breakpoint_index: list.index($all_breakpoint_keys, $breakpoint);
	
	$largest_subset_index: 1;
	@for $i from 1 through list.length($all_breakpoint_keys) {
		@if $i < $breakpoint_index {
			$current_breakpoint: list.nth($all_breakpoint_keys, $i);
			@if list.index($breakpoint_subset_keys, $current_breakpoint) != null {
				$largest_subset_index: list.index($breakpoint_subset_keys, $current_breakpoint);
			}
		}
	}
	
	@return list.nth($breakpoint_subset_keys, $largest_subset_index);
}


/// Create breakpoints
/// @param {list} $names
/// @param {int} $start: Smallest non-zero breakpoint
/// @param {int} $end: Largest breakpoint
/// @param {float} $curve
/// @param {map} $additional
/// @param {int} $round_to
/// @return {map} *
@function create_breakpoints($names, $start, $end, $curve, $additional, $round_to: 4) {
	@if $start < config.$content_min_width {
		@warn 'A value of #{$start} for the first non-zero breakpoint ($breakpoint_width_min) might be a bit small. The minimum content width is #{config.$content_min_width}, which means that users would never see the first breakpoint.';
	}
	
	$start: util.strip_units($start);
	$end: util.strip_units($end);
	
	@if $start % $round_to > 0 {
		@warn 'The value of #{$start} for the first non-zero breakpoint is not a multiple of #{$round_to}, so its interpolated breakpoint value will be different.';
	}
	@if $end % $round_to > 0 {
		@warn 'The value of #{$end} for the last breakpoint is not a multiple of #{$round_to}, so its interpolated breakpoint value will be different.';
	}
	
	$values: list.join((0,), util.interpolate(
		$start: math.round(calc($start / $round_to)),
		$end: math.round(calc($end / $round_to)),
		$count: list.length($names) - 1,
		$curve: $curve,
		$round: true
	));
	
	$generated: ();
	@for $i from 1 through list.length($names) {
		$name: list.nth($names, $i);
		$value: (list.nth($values, $i) * $round_to * 1px);
		$generated: map.set($generated, $name, $value);
	}
	
	@if list.length(map.values($additional)) == 0 {
		@return $generated;
	}
	
	// Remove entries from generated breakpoints if they match either the name or
	// size of an additional breakpoint defined explicitly
	$remove_additional_keys: ();
	@each $key, $value in $additional {
		$additional_key_index: list.index(map.keys($generated), $key);
		$additional_value_index: list.index(map.values($generated), $value);
		
		@if $additional_key_index != null {
			$value_generated: map.get($generated, $key);
			@warn 'The breakpoint named "#{$key}" in $breakpoint_additions (#{$value}) already exists as a generated breakpoint. The generated "#{$key}" breakpoint (#{$value_generated}) has been removed.';
			$remove_additional_keys: list.append($remove_additional_keys, $key);
		}
		
		@else if $additional_value_index != null {
			$key_generated: list.nth(map.keys($generated), $additional_value_index);
			@warn 'The value for "#{$key}" in $breakpoint_additions (#{$value}) is the same as the generated breakpoint value for "#{$key_generated}". The generated "#{$key}" breakpoint has been removed.';
			$remove_additional_keys: list.append($remove_additional_keys, $key_generated);
		}
	}
	
	@each $key in $remove_additional_keys {
		$generated: map.remove($generated, $key);
	}
	
	$all: util.map_insert($generated, $additional);
	
	@each $key, $value in $all {
		@if
			not util.is_zero($value)
			and $value < config.$content_min_width
		{
			@warn 'A value of #{$value} for the breakpoint named "#{$key}" might be a bit small. The minimum content width is #{config.$content_min_width}, which means that users would never see the first breakpoint.';
		}
	}
	
	@return $all;
}






@mixin set_max() {
	$content_max_width: map.get($breakpoints, config.$content_max_width_breakpoint) !global;
	$content_max_width_extended: map.get($breakpoints, config.$content_max_width_extended_breakpoint) !global;
}



@mixin set_gutter_by_type {
	$gutter: map.get((
		fixed: $gutter_fixed,
		stepped: $gutter_stepped,
		flexible: $gutter_flexible,
	), $gutter_type) !global;
}


@mixin set_gutter_flexible {
	$gutter_flexible: (
		x: (
			config.$gutter_flexible_min_x,
			(util.truncate(calc(config.$gutter_flexible_max_x / $content_max_width)) * 100vw),
			config.$gutter_flexible_max_x,
		),
		y: (
			20px,
			8vw,
			48px,
		),
		outer: (
			20px,
			6vw,
			48px
		),
	) !global;
}





/// Define column counts
/// @param {map} $set
@mixin grid_setup($set) {
	@each $breakpoint, $column_count in $set {
		$media_query: $breakpoint;
		
		$use_between_operator: true;
		@if $use_between_operator {
			$next_smallest_breakpoint: find_next_smallest_breakpoint(
				map.keys($set), $breakpoint
			);
			$media_query: '>< #{$breakpoint} #{$next_smallest_breakpoint}';
		}
		
		@include b($media_query) {
			grid-template-columns: repeat($column_count, 1fr);
			--grid-items: #{$column_count};
		}
	}
}


/// Define wire grid
/// @param {map} $set
@mixin wire_setup($set) {
	@each $breakpoint, $column_count in $set {
		$next_smallest_breakpoint: find_next_smallest_breakpoint(
			map.keys($set), $breakpoint
		);
		@include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
			> :nth-child(#{$column_count}n+1) {
				--wire-end-right: 100%;
				--wire-end-border-left: 0;
			}
			> :nth-child(#{$column_count}n) {
				--wire-end-left: 100%;
				--wire-end-margin-right: 0;
				--wire-end-border-right: 0;
			}
			> :nth-child(#{$column_count}n),
			> :nth-child(#{$column_count}n+1) {
				--wire-end-width: var(--wire-end-width-visible);
			}
		}
	}
}


/// Define responsive layout
/// 
/// For any one item, the parameters can be any combination of:
/// 6,     // 6 columns wide
/// 8 3,   // 8 columns wide, starting on column 3
/// _ 3,   // No column span specified, starting on column 3
/// -1,    // Full-width (same as -1 1)
/// -2 3,  // Start on column 3, end on the second column from the end
/// r 2,   // 2 rows tall
/// r 1 4, // 1 row tall, starting on row 4
/// r _ 4, // No row span specified, starting on row 4
/// o -2,  // order -2
/// 
/// Parameters must be specified in this order:
/// 1. [column span] [column start]
/// 2. [row span] [row start]
/// 3. order
/// 
/// Specify parameters for one item using space-delimited lists:
/// @include layout((
///   sm: 6,
///   md: 10 1 r 2,
///   lg: 8 3,
/// ));
/// 
/// Specify parameters for multiple items, separated by commas:
/// @include layout((
///   sm: (6, 6, 6),
///   md: (7 2, 5 r 2, 6 o -2),
///   lg: (8, 4),
/// ));
/// 
/// Enabling repeat causes parameters to affect all items, using
/// multipliers for CSS selectors:
/// - Repeat off: :nth-child(2)
/// - Repeat on:  :nth-child(2n)
/// 
/// Repeat enabled: odd-numbered items will be 8 columns wide, and
/// even-numbered items will be 4 columns wide:
/// @include layout((
///   lg: (8, 4),
/// ), $repeat: true);
/// 
/// Repeat disabled: any items past the second one will not inherit their
/// settings from smaller breakpoints, or not have any settings:
/// @include layout((
///   lg: (8, 4),
/// ), $repeat: false);
/// 
/// @param {map} $set
/// @param {boolean} $repeat
/// @param {boolean} $self
@mixin layout($set, $repeat: true, $self: false) {
	$delimiter_row: r;
	$delimiter_order: o;
	
	@each $breakpoint, $elements in $set {
		@if
			meta.type_of($elements) != list
			or list.separator($elements) != comma
		{
			$elements: ($elements,);
		}
		
		// Use next-smallest breakpoint to avoid creating over-zealous item styles
		// that are difficult to override at larger breakpoints
		// TODO: this may be unnecessary for many grid styles, it may be most
		// useful when the number of items in a row is changing and the items on
		// ends of each row have specific styles, such as the wire grid
		$next_smallest_breakpoint: find_next_smallest_breakpoint(
			map.keys($set), $breakpoint
		);
		
		@include b($breakpoint) {
		// @include b('>< #{$breakpoint} #{$next_smallest_breakpoint}') {
			@for $index from 1 through list.length($elements) {
				$list: list.nth($elements, $index);
				
				// Split params to separate order from column and row
				$split_column_row_order: util.split_list($list, $delimiter_order);
				$column_row: map.get($split_column_row_order, a);
				$order: map.get($split_column_row_order, b);
				
				// Split params to separate row from column
				$split_column_row: util.split_list($column_row, $delimiter_row);
				$column: map.get($split_column_row, a);
				$row: map.get($split_column_row, b);
				
				// TODO: if repeat and all elements have the same config, only spit out
				// the rules once
				// Example: sm: (6, 6, 6) => sm: (6)
				
				// TODO: keep track of settings from breakpoint to breakpoint, and if
				// an element uses the same settings as the previous breakpoint, don't
				// repeat those rules
				// Example: (
				//   sm: (6, 4),
				//   md: (6, 3), => Don't repeat rules for first element
				//   lg: (6, 3), => Don't repeat rules for first or second element
				//   xl: (8, 2),
				// )
				
				@if $self {
					// TODO: is there a better way to do this?
					@include grid_plot($column, $row, $order);
				} @else {
					@if $index == 1 and $repeat {
						// TODO: could possibly see how many items there are in the
						// definition and use that to create a selector for the first item
						// that's more like :nth-child(2n+1), so that it doesn't apply to
						// all items in the grid, most of which are then overridden
						> * {
							@include grid_plot($column, $row, $order);
						}
					} @else {
						> :nth-child(#{$index}#{if($repeat, n, '')}) {
							@include grid_plot($column, $row, $order);
						}
					}
				}
			}
		}
	}
}


/// Grid plot
/// @param {int | list} $column
/// @param {int | list} $row
/// @param {int} $order
@mixin grid_plot($column, $row, $order) {
	@if $column {
		@include grid_plot_axis(column, $column);
	}
	@if $row {
		@include grid_plot_axis(row, $row);
	}
	@if $order {
		order: $order;
	}
}


/// Grid plot axis
/// @param {string} $type (row or column)
/// @param {int | list} $params
@mixin grid_plot_axis($type, $params) {
	@if 
		meta.type_of($params) == list
		and list.length($params) == 1
	{
		$params: list.nth($params, 1);
	}
	
	$has_start: meta.type_of($params) == list;
	@if $has_start {
		@if list.nth($params, 1) == _ {
			grid-#{$type}-start: list.nth($params, 2);
		}
		
		@else {
			$span: if(list.nth($params, 1) > 0, span, unquote(''));
			grid-#{$type}: list.nth($params, 2) / $span list.nth($params, 1);
			@if $type == column {
				--content-width: #{list.nth($params, 1)};
			}
		}
	}
	
	@else {
		$start: if($params > 0, auto, 1);
		$span: if($params > 0, span, unquote(''));
		grid-#{$type}: $start / $span $params;
		@if $type == column {
			--content-width: #{$params};
		}
	}
}


/// Float element within grid
/// - Explicit container width
/// - Optionally implicit float offset
/// 
/// @param {string} $direction
/// @param {int} $in ($container_column_count): Number of columns occupied by
///   containing element
/// @param {int} $width ($float_column_count): Width of floated element
/// @param {int} $offset ($float_offset_columns): Positive integer, -1 = auto
@mixin grid_float($direction, $in, $width, $offset: -1) {
	$opposite_direction: if($direction == right, left, right);
	$container_column_count: $in;
	$float_column_count: $width;
	$float_offset_columns: $offset;
	
	// TODO: add support for responsive params
	// $container_column_count: (
	// 	md: 8,
	// 	lg: 6,
	// ),
	// $float_column_count: (
	// 	md: 4,
	// 	lg: 3,
	// ),
	
	// TODO: $float_offset_columns doesn't really make sense, looks like it might have an off by one error
	
	// Calculate width of floated element
	$float_width: util.truncate(
		calc(($float_column_count / $container_column_count) * 100%)
	);
	$float_width_factor: util.truncate(
		calc(($container_column_count - $float_column_count) / $container_column_count)
	);
	
	$gutter_float: gutter(x, $as_list: true);
	$gutter_float_width: util.list_to_clamp(util.operate_list($gutter_float, $multiply: $float_width_factor));
	
	float: $direction;
	width: calc($float_width - $gutter_float_width);
	margin-#{$opposite_direction}: gutter(x);
	
	$previous_float_offset_percentage: null;
	$previous_gutter_float_offset: null;
	
	@each $breakpoint, $columns in config.$grid_columns {
		
		// TODO: consider removing this auto calculation and making it a required parameter
		// Set float offset automatically when not specified, assuming the content
		// area is centered, and we want to send the floated element all the way to
		// the edge of the grid
		@if $float_offset_columns == -1 {
			$float_offset_columns: math.floor(
				calc(($columns - $container_column_count) / 2)
			);
		}
		
		// What percentage of the content area width is the float offset?
		$float_offset_factor: calc($float_offset_columns / $container_column_count);
		$float_offset_percentage: util.truncate($float_offset_factor * -100%);
		
		$gutter_float_offset: util.list_to_clamp(util.operate_list($gutter_float, $multiply: $float_offset_factor));
		
		// Prevent repeating rules
		@if (
			$float_offset_percentage != $previous_float_offset_percentage
			or $gutter_float_offset != $previous_gutter_float_offset
		) {
			@include b($breakpoint) {
				@if not is_zero($float_offset_percentage) {
					margin-#{$direction}: calc($float_offset_percentage - $gutter_float_offset);
				} @else {
					margin-#{$direction}: 0;
				}
			}
			$previous_float_offset_percentage: $float_offset_percentage;
			$previous_gutter_float_offset: $gutter_float_offset;
		}
	}

}


/// Float element within grid
/// - Implicit container width
/// - Explicit float offset
/// 
/// Advantages over grid_float():
/// - Don't need to know the width of the floated element's container
/// - Possibly less generated CSS?
/// 
/// Disdvantages:
/// - Must specify the float offset explicitly
/// - No automatically extending floated element to edge of grid
/// 
/// @param {string | map} $direction
/// @param {int | map} $width ($float_column_count): Width of floated element
/// @param {int | map} $offset ($float_offset_columns): Positive integer
@mixin grid_float_auto_container($direction, $width, $offset: 0) {
	$first_breakpoint_name: list.nth(map.keys($breakpoints), 1);
	
	// Convert single values to maps
	@if meta.type_of($direction) != map {
		$direction: (
			#{$first_breakpoint_name}: $direction,
		);
	}
	@if meta.type_of($width) != map {
		$width: (
			#{$first_breakpoint_name}: $width,
		);
	}
	@if meta.type_of($offset) != map {
		$offset: (
			#{$first_breakpoint_name}: $offset,
		);
	}
	
	$float_column_count: $width;
	$float_offset_columns: $offset;
	
	@each $breakpoint in map.keys($breakpoints) {
		@if
			map.has_key($direction, $breakpoint)
			or map.has_key($float_offset_columns, $breakpoint)
		{
			@include b($breakpoint) {
				@if map.has_key($direction, $breakpoint) {
					$float_direction: map.get($direction, $breakpoint);
					$opposite_direction: if($float_direction == right, left, right);
					float: $float_direction;
					margin-#{$opposite_direction}: gutter(x);
				}
				
				// For every breakpoint that has either a direction or offset specified,
				// we need to update the margins on each side. If a direction or offset
				// is not specified for that breakpoint, use the largest smaller
				// breakpoint that is explicitly defined for that breakpoint.
				$smaller_direction: find_largest_smaller_breakpoint(map.keys($direction), $breakpoint);
				$offset_direction: map.get($direction, $smaller_direction);
				$smaller_offset: find_largest_smaller_breakpoint(map.keys($float_offset_columns), $breakpoint);
				$offset_columns: map.get($float_offset_columns, $smaller_offset);
				
				@if is_zero($offset_columns) {
					margin-#{$offset_direction}: 0;
				} @else {
					$offset_factor: calc($offset_columns / var(--content-width));
					$offset_percentage: calc(($offset_columns * -100%) / var(--content-width));
					margin-#{$offset_direction}: calc($offset_percentage - (gutter(x) * util.truncate($offset_factor)));
				}
			}
		}
		
		// Calculate width of floated element
		@if map.has_key($float_column_count, $breakpoint) {
			@include b($breakpoint) {
				$float_columns: map.get($float_column_count, $breakpoint);
				$float_width: calc(($float_columns * 100%) / var(--content-width));
				$float_width_factor: calc(1 - ($float_columns / var(--content-width)));
				width: calc($float_width - (gutter(x) * $float_width_factor));
			}
		}
	}
}


@mixin gutter_settings {
	
	// @debug 'config.$gutter_base_x (#{meta.type_of(config.$gutter_base_x)}):';
	// @debug config.$gutter_base_x;
	
	
	:root {
		--gutter-x: #{config.$gutter_base_x};
		--gutter-y: #{config.$gutter_base_y};
		--gutter-outer: #{config.$gutter_base_outer};
		--gutter-stepped-x: #{config.$gutter_base_x};
		--gutter-stepped-y: #{config.$gutter_base_y};
		--gutter-stepped-outer: #{config.$gutter_base_outer};
		--content-width: 0;
		
		@each $breakpoint, $scale in config.$gutter_stepped_scale {
			@include b($breakpoint) {
				--gutter-stepped-x: #{math.round(config.$gutter_base_x * $scale)};
				--gutter-stepped-y: #{math.round(config.$gutter_base_y * $scale)};
				--gutter-stepped-outer: #{math.round(config.$gutter_base_outer * $scale)};
			}
		}
	}
}

