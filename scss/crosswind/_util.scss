@use 'sass:string';
@use 'sass:map';
@use 'sass:math';
@use 'sass:meta';
@use 'sass:list';


/// Convert string to number
/// @link https://kittygiraudel.com/2014/01/15/sass_string_to_number/
/// @author Kitty Giraudel
/// @param {String | Number} $value - Value to be parsed
/// @return {Number} *
@function convert_to_number($value) {
  @if meta.type_of($value) == number {
    @return $value;
  } @else if meta.type_of($value) != string {
    @error 'Value for convert_to_number() should be a number or a string';
  }
  
  $result: 0;
  $digits: 0;
  $is_negative: string.slice($value, 1, 1) == '-';
  $numbers: ('0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9);
  
  @for $i from if($is_negative, 2, 1) through string.length($value) {
    $character: string.slice($value, $i, $i);
    
    @if not (
      $character == '.'
      or list.index(map.keys($numbers), $character)
    ) {
      @return append_unit_to_value(if($is_negative, ($result * -1), $result), string.slice($value, $i));
    }
    
    @if $character == '.' {
      $digits: 1;
    } @else if $digits == 0 {
      $result: (($result * 10) + map.get($numbers, $character));
    } @else {
      $digits: ($digits * 10);
      $result: ($result + calc(map.get($numbers, $character) / $digits));
    }
  }
  
  @return if($is_negative, ($result * -1), $result);
}


/// Append unit to numeric value
/// @link https://kittygiraudel.com/2014/01/15/sass_string_to_number/
/// @author Kitty Giraudel
/// @param {Number} $value - Value to add unit to
/// @param {String} $unit - String representation of the unit
/// @return {Number} - `$value` expressed in `$unit`
@function append_unit_to_value($value, $unit) {
  $units: ('px': 1px, 'cm': 1cm, 'mm': 1mm, '%': 1%, 'ch': 1ch, 'pc': 1pc, 'in': 1in, 'em': 1em, 'rem': 1rem, 'pt': 1pt, 'ex': 1ex, 'vw': 1vw, 'vh': 1vh, 'vmin': 1vmin, 'vmax': 1vmax);
  @if not list.index(map.keys($units), $unit) {
    @error 'Invalid unit: #{$unit}';
  }
  
  @return ($value * map.get($units, $unit));
}


/// Is this value zero?
/// @param {mixed} $value
/// @return {bool} *
@function is_zero($value) {
  @return
    meta.type_of($value) == number
    and strip_units($value) == 0
  ;
}


/// Strip units from number by math
/// @param {number} $number
/// @return {unitless number} *
@function strip_units($number) {
	@if
		meta.type_of($number) == number
		and not math.is_unitless($number)
	{
		$one_of_unit: (($number * 0) + 1);
		@return calc($number / $one_of_unit);
	}
	@return $number;
}


/// Strip units from number by string manipulation
/// @param {number} $number
/// @return {unitless number} *
@function strip_units_by_string($number) {
  @if
    meta.type_of($number) == number
    and not math.is_unitless($number)
  {
    $num_length: string.length(#{$number});
    $unit_length: string.length(math.unit($number));
    $unitless: string.slice(#{$number}, 1, ($num_length - $unit_length));
    @return convert_to_number($unitless);
  }
  // @warn '"#{$number}" is not a number, or it does not have any units to strip away.';
  @return $number;
}


/// Quick sort
/// @author Sam Richards
/// @param {List} $list - list to sort
/// @return {List} *
@function quick_sort($list) {
  $less_than: ();
  $equal: ();
  $greater_than: ();
	
  @if list.length($list) > 1 {
    $seed: list.nth($list, math.ceil(calc(list.length($list) / 2)));
		
    @each $item in $list {
      @if ($item == $seed) {
        $equal: list.append($equal, $item);
      } @else if ($item < $seed) {
        $less_than: list.append($less_than, $item);
      } @else if ($item > $seed) {
        $greater_than: list.append($greater_than, $item);
      }
    }
		
    @return list.join(
			list.join(
				quick_sort($less_than),
				$equal
			),
			quick_sort($greater_than)
		);
  }
	
  @return $list;
}


/// Sort map by numeric values
/// @param {map} $input
/// @return {map} *
@function map_sort($input) {
	$values_sorted: quick_sort(map.values($input));
	$map_sorted: ();
	@each $value in $values_sorted {
		$index: list.index(map.values($input), $value);
		$key: list.nth(map.keys($input), $index);
		$map_sorted: map.set($map_sorted, $key, $value);
	}
	@return $map_sorted;
}


/// Inject one sorted map into another, maintaining sort order
/// @param {map} $source
/// @param {map} $insert
/// @return {map} *
@function map_insert($source, $insert) {
	$insert_sorted: map_sort($insert);
	
	// Insert values into source map
	@each $key, $value in $source {
		@each $insert_key, $insert_value in $insert_sorted {
			$stop: false;
			@if
				$value > $insert_value
				and not map.has_key($source, $insert_key)
				and not $stop
			{
				$before_map: map_subset($source, $before: $key);
				$from_map: map_subset($source, $from: $key);
				
				$source: map.merge(
					map.merge(
						$before_map,
						(#{$insert_key}: $insert_value),
					),
					$from_map
				);
				
				$stop: true;
			}
		}
	}
	
	// If last insertion value is larger than last source value, append it
	$last_value: list.nth(
		map.values($source),
		list.length(map.values($source))
	);
	$last_insert_value: list.nth(
		map.values($insert_sorted),
		list.length(map.values($insert_sorted))
	);
	@if $last_insert_value > $last_value {
		$last_insert_key: list.nth(
			map.keys($insert_sorted),
			list.length(map.keys($insert_sorted))
		);
		$source: map.set($source, $last_insert_key, $last_insert_value);
	}
	
	@return $source;
}


/// Get subset of map keys and values
/// @param {map} $map
/// @param {string} $before
/// @param {string} $to
/// @param {string} $from
/// @param {string} $after
/// @return {map} *
@function map_subset($map, $before: null, $to: null, $from: null, $after: null) {
	$output: ();
	
	@if $from != null and $to != null {
		@return map_subset(map_subset($map, $from: $from), $to: $to);
	}
	
	// Get all pairs before but not including $before key
	@if $before != null {
		$stop: false;
		@each $key, $value in $map {
			@if $key != $before and not $stop {
				$output: map.set($output, $key, $value);
			} @else if $key == $before {
				$stop: true;
			}
		}
	}
	
	// Get all pairs up to and including $to key
	@else if $to != null {
		$stop: false;
		@each $key, $value in $map {
			@if not $stop {
				$output: map.set($output, $key, $value);
			}
			@if $key == $to {
				$stop: true;
			}
		}
	}
	
	// Get all pairs starting with $from key
	@else if $from != null {
		$start: false;
		@each $key, $value in $map {
			@if $key == $from {
				$start: true;
			}
			@if $start {
				$output: map.set($output, $key, $value);
			}
		}
	}
	
	// Get all pairs after $after key
	@else if $after != null {
		$start: false;
		@each $key, $value in $map {
			@if $start {
				$output: map.set($output, $key, $value);
			}
			@if $key == $after {
				$start: true;
			}
		}
	}
	
	@return $output;
}


/// Show inline warning
/// @param {string} $message
@mixin warning($message) {
	position: relative;
	overflow: auto;
	&::before {
		content: $message;
		position: absolute;
		z-index: 9999;
		left: 12px;
		right: 12px;
		top: 12px;
		padding: 12px 16px;
		border-radius: 8px;
		background: color(warning);
		box-shadow: 0 8px 24px rgb(0 0 0 / 0.5);
		font-size: 20px;
		color: color(white);
		text-align: left;
		text-transform: none;
		letter-spacing: normal;
	}
}
