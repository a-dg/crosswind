@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:math';
@use 'sass:color';

@use 'config' as cc;
@use 'util';


$color_variable_prefix: color !default;
$_inset_variant_keyword: apply;


// @debug cc.get(colors);

// TODO: consider making a local copy of user's site config to be augmented by Crosswind in the setup process

// TODO: a lot of this will need to be updated if variants include things other than colors



/// Format color name as CSS variable
/// @param {string} $name
/// @return {string} *
@function color_css_var($name) {
	@return --#{$color_variable_prefix}-#{util.replace(#{$name}, '_', '-')};
}


/// Convert raw color keys to strings
/// @param {map} $colors
/// @return {map} *
@function convert_raw_color_keys($colors) {
	$normalized_colors: ();
	@each $key, $value in $colors {
		$normalized_colors: map.set($normalized_colors, '' + $key, $value);
	}
	@return $normalized_colors;
}


/// Get color by name, optionally from a specific variant
/// @param {string | color} $color_name
/// @param {string | color} $variant_name
/// @return {string} CSS color variable
@function color($color_name, $variant_name: null) {
	@if meta.type_of($color_name) == color {
		$color_name: '' + $color_name;
	}
	
	$default_variant: _get_default_variant();
	@if
		not map.has_key(cc.get(colors), $color_name)
		and not map.has_key($default_variant, $color_name)
	{
		@warn 'Unknown color name: #{$color_name}';
	}
	
	// Get color from specific variant
	@if $variant_name {
		$color_name: #{cc.get(variants, #{$variant_name}, #{$color_name})};
	}
	
	@return var(color_css_var($color_name));
}


// Warn if color key is defined in variant that is not in the default
@mixin check_variant_keys {
	$default_key: _get_default_variant(true);
	$default_variant: _get_default_variant();
	@each $variant_name, $variant_map in cc.get(variants) {
		@each $color_key, $color_value in $variant_map {
			@if
				_is_creatable_color($color_key, $color_value)
				and not map.has_key($default_variant, $color_key)
			{
				@warn 'Color "#{$color_key}" in variant "#{$variant_name}" is not defined in default variant "#{$default_key}"';
			}
		}
	}
}


// Create new colors for variant values with opacity
@function create_transparent_variant_colors() {
	$new_colors: ();
	$new_variants: ();
	
	@each $variant_name, $variant_map in cc.get(variants) {
		@each $color_key, $color_name in $variant_map {
			@if
				meta.type_of($color_name) == list
				and _is_creatable_color($color_key, $color_name)
			{
				$opacity: util.convert_to_number(list.nth($color_name, 2));
				$color_name: '' + list.nth($color_name, 1);
				
				@if math.unit($opacity) == '%' {
					$opacity: calc($opacity / 1%);
				}
				
				$opacity_int: $opacity;
				@if $opacity < 1 {
					$opacity_int: ($opacity * 100);
				}
				
				$color_value: map.get(cc.get(colors), $color_name);
				$color_name_new: '#{$color_name}-#{$opacity_int}';
				
				$transparency: ((100 - $opacity_int) * -1%);
				$color_value_new: color.scale($color_value, $alpha: $transparency);
				
				// Update maps with transparentized colors
				$new_colors: map.set($new_colors, $color_name_new, $color_value_new);
				$new_variants: map.set($new_variants, $variant_name, $color_key, $color_name_new);
			}
		}
	}
	
	@return (
		colors: $new_colors,
		variants: $new_variants,
	);
}


/// Define raw colors and default variant colors
@mixin define_color_variables {
	$default_variant: _get_default_variant();
	:root {
		@each $key, $value in cc.get(colors) {
			#{color_css_var($key)}: #{$value};
		}
		@each $key, $value in $default_variant {
			@include create_color_css_var($key, $value);
		}
	}
}


/// Define all variant classes
@mixin define_variant_classes {
	$updated_variants: ();
	@each $variant_name, $variant_map in cc.get(variants) {
		.v-#{'' + $variant_name} {
			$result: _build_variant_map($variant_map);
			$updated_variants: map.set($updated_variants, variants, $variant_name, $result);
			@each $key, $value in $result {
				@include create_color_css_var($key, $value);
			}
		}
	}
	@include cc.set_deep($updated_variants);
}


/// Build map of all variant colors, with recursive inheritance
/// @param {map} $variant_map
/// @param {boolean} $is_default
/// @return {map} *
@function _build_variant_map($variant_map, $is_default: false) {
	$map: ();
	@each $key, $value in $variant_map {
		@if _is_creatable_color($key, $value) {
			$map: map.set($map, $key, $value);
		}
	}
	
	// Get properties from next parent variant up the inheritance chain, unless
	// we've already arrived at the default variant
	@if not $is_default {
		$inherit_name: map.get($variant_map, inherit);
		@if not $inherit_name {
			$inherit_name: _get_default_variant(true);
			$is_default: true;
		}
		$inherit_map: map.get(cc.get(variants), #{$inherit_name});
		$map: map.merge(_build_variant_map($inherit_map, $is_default), $map);
	}
	
	@return $map;
}


/// Assign specific variant
/// @param {string} $name
@mixin variant($name) {
	$variant_map: map.get(cc.get(variants), #{$name});
	@each $key, $value in $variant_map {
		@include create_color_css_var($key, $value);
	}
}


/// Is this value in the variant map a reference to an inset variant?
/// @param {string | color | list} $value
/// @return {boolean} *
@function _is_inset_variant($value) {
	@return (
		meta.type_of($value) == list
		and list.index($value, $_inset_variant_keyword)
	);
}


/// Define inset variants
/// 
/// Inset variants allow nesting one variant inside of another, allowing
/// relating multiple variants to one another dynamically. An inset variant is
/// marked by the use of "apply" in its value, indicating that it's not an
/// actual color. Variants can have an arbitrary number of inset variants.
/// 
/// Example:
/// white: (
///   bg: white,
///   text: black,
///   inverse: apply black, <- Refers to the variant named "black"
/// ),
/// black: (
///   bg: black,
///   text: white,
///   inverse: apply white, <- Refers to the variant named "white"
/// ),
@mixin define_inset_variants {
	$default_variant: _get_default_variant();
	@include _create_inset_variant_css_var($default_variant);
	
	@each $variant_name, $variant_map in cc.get(variants) {
		.v-#{'' + $variant_name} {
			@include _create_inset_variant_css_var($variant_map);
		}
	}
}


@function _get_default_variant($key_only: false) {
	@if $key_only {
		@return util.map_first_key(cc.get(variants));
	}
	
	@return util.map_first_value(cc.get(variants));
}


@mixin _create_inset_variant_css_var($variant_map) {
	@each $key, $value in $variant_map {
		@if _is_inset_variant($value) {
			$variant_name: list.nth($value, 2);
			$inset_map: map.get(cc.get(variants), #{$variant_name});
			
			.v-#{$key} {
				@each $inset_key, $inset_value in $inset_map {
					@include create_color_css_var($inset_key, $inset_value);
				}
			}
		}
	}
}


@mixin create_color_css_var($key, $value) {
	@if _is_creatable_color($key, $value) {
		#{color_css_var($key)}: #{color($value)};
	}
}


/// Can this color be created as a CSS variable?
/// 
/// Entries in variants that refer to other variants should not be created as
/// CSS color variables. This includes "inherit", and any entries using "apply"
/// to refer to another variant.
/// 
/// @param {string} $key
/// @param {string | color | list} $value
/// @return {boolean} *
@function _is_creatable_color($key, $value) {
	@return (
		$key != inherit
		and not _is_inset_variant($value)
	);
}
